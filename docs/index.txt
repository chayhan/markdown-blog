2:"$Sreact.suspense"
3:I[2703,["93","static/chunks/93-3c33722948fb8147.js","931","static/chunks/app/page-d7c3b2d329e171ab.js"],""]
10:I[4632,["93","static/chunks/93-3c33722948fb8147.js","729","static/chunks/729-fcd05f6bcbb192cf.js","185","static/chunks/app/layout-2fd917157e5d2d7a.js"],""]
11:I[3729,["93","static/chunks/93-3c33722948fb8147.js","729","static/chunks/729-fcd05f6bcbb192cf.js","185","static/chunks/app/layout-2fd917157e5d2d7a.js"],"Image"]
12:I[7723,["93","static/chunks/93-3c33722948fb8147.js","729","static/chunks/729-fcd05f6bcbb192cf.js","185","static/chunks/app/layout-2fd917157e5d2d7a.js"],""]
13:I[1949,[],""]
14:I[881,[],""]
4:T1818,
## 증상 원인

내 마크다운 블로그를 개발하던 중 이게 왠일?

블로그에 테마 토글 기능을 추가해서 다크모드를 사용할 때에도 라이트 모드를, 또는 그 반대를 활용할 수 있도록 만들었는데, 내가 시스템에서 설정한 테마 색이 시스템 설정을 따라 가다보니 시스템 테마가 먼저 적용이 되고, 그 다음에 토글 기능으로 설정된 테마가 나중에 적용된다.

일명 깜빡거리는 증상인데 어떻게 된일인지 생각해봤다.

## HTML Blocking

보통 `DOM` 이 생성될 때,  중간에 script 태그를 만나게 되면 DOM 생성 과정이 중단됩니다.

이걸 이용하면 body 가 처음에 흰색이던 아니던 우리가 보기전에 `head` 태그에서 배경색을 지정해버리면 처음부터 페이지 색상이 그랬던 것처럼 로딩이 잘 될거라 생각했습니다.

---

# 대망의 첫 시도. 그리고 실패

실패했습니다. 하하. 하지만 생각보다 실패의 원인은 넥스트에 깊은 곳에 자리 잡고 있는 것으로 보입니다. 실패한 원인에 대해 얘기해보고자 합니다.

## 내 index 페이지에서의 로딩 방식이 사뭇 다르다?

제 블로그는 Next.js Static Site Generation을 이용합니다. 정적 페이지를 생성을 해주어 정적 페이지로도 라우팅이 가능하게끔 구성되어 있는데요. 이 방식에 따르면 제 페이지는 반드시 정적 페이지가 생성되어야 하고, 클라이언트 사이드 코드는 극소수만 존재해야했다.

### 그런데 `__next_error__` 값의 `id` 속성이 html에 붙어있었다.

이게 뭐지? 싶었는데 알고보니 클라이언트 단에서 에러가 난 것이였다. 이걸 어떻게 알았냐고?

`Postlist` 컴포넌트를 주석처리하니 놀랍게도 해당 속성이 없이 제대로 인덱스 페이지가 렌더링 되었다. 어떻게 된 일인지 생각을 해봤는데 놀랍게도 `useSearchParam` 이 원인이였다.

## 진짜는 `useSearchParam` 에 있었다..

어떻게 알아냈냐면 결국 넥스트가 SSG를 할 때 나는 오류구문을 어떻게든 찾아내게 계속 빌드를 해서 알아냈는데, 

[Entire page deopted into client-side rendering](https://nextjs.org/docs/messages/deopted-into-client-rendering)

위와 같은 사이트로 이동 되었는데 역시나,, 다른 것들도 아니고 useSearchParam 때문이였다.

이게 뭐냐면 클라이언트의 페이지에 링크에 저장된 파라미터값을 가져오는 훅이다. 이걸 사용할 때 `Suspense` 로 범위를 묶어주어야 전체 CSR이 안된다고 한다.

그래서 깜빡이는 현상이 생긴 것이다. 이것 때문에 CSR 렌더링이 전체 범위로 바뀌기 때문에 어떻게 똥꼬쇼를 해도 내가 만든 코드는 전부 페이지 로드가 끝이 나고 실행이 됐던 것이였다.

## Suspense 가 뭔지?

suspense는 CSR이 어디서부터 어디까지 되게 할 건지 범위를 지정해주는 것이다.

지금 내가 만들고 있는건 정적페이지인데, 어디서부터 `CSR`을 해야하는지 지정을 명확하게 해준다.

단순히 `use client;` 를 선언한다고 이게 딱딱 맞추어 지는 건 아닌게, 아래가 `page.tsx` 인데 잘보면 `Postlist` 컴포넌트는 그냥 다른 `div` 컴포넌트와 형제 관계이므로 이 형제 관계인 요소들도 전부 CSR이 되고, 이런식으로 CSR이 타고올라가다보면 전체 범위가 CSR이 되는 것이다…!

따라서 비동기로 생성되는 부분만 따로 선렌더링을 할 JSX 컴포넌트를 주고 후에 CSR로 렌더링되게 만들 게 해주는 것이 Suspense 인 것이다.

```jsx
import Postlist from "./Postlist";
import styles from "./page.module.css";
import { Article, getArticleList } from "@/ts/article";

export default function Page() {
  const articles = getArticleList();
  return <div className={styles.mainWrap}>
    <div className={styles.title}>Posts</div>
    <div className={styles.description}>다양한 주제로 글을 씁니다.</div>
    <div className={styles.hr} />
    
    <Postlist articleList={articles} />
  </div>
}
```

위 코드를 아래와 같이 바꿔주었다.

```jsx
import Postlist from "./Postlist";
import { Suspense } from "react";
import styles from "./page.module.css";
import { getArticleList } from "@/ts/article";

function PostlistFallback() {
  return <>
    loading...
  </>
}

export default function Page() {
  return <div className={styles.mainWrap}>
    <div className={styles.title}>Posts</div>
    <div className={styles.description}>다양한 주제로 글을 씁니다.</div>
    <div className={styles.hr} />
    
    <Suspense fallback={<PostlistFallback />}>
      <Postlist articleList={getArticleList()} />
    </Suspense>
  </div>
}
```

이렇게 바꾸고나니 놀랍게도 에러가 뜨지 않고 정상적으로 정적페이지가 렌더링 되었다! 더욱 내 블로그가 최적화 되었다고 생각하니 기쁘지 않을수가 없다.

아래는 `Suspense` 기능에 관한 더 자세한 AI 검색 결과이다.

안녕하세요, 이것은 Bing입니다. 😊

React.js에서 Suspense는 비동기 작업을 관리하는 기능입니다. Suspense를 사용하면 컴포넌트가 데이터를 기다리고 있는 것을 React에게 알릴 수 있고, 대신에 fallback 컴포넌트를 보여줄 수 있습니다. 예를 들어, 다음과 같이 코드를 작성하면 UserList 컴포넌트가 로딩될 때까지 Spinner 컴포넌트를 보여줍니다.

```jsx
<Suspense fallback={<Spinner />}>
  <UserList />
</Suspense>

```

Suspense는 React v16.6부터 실험적으로 도입되었고, React v18에서 정식으로 지원됩니다. Suspense를 사용하면 컴포넌트의 렌더링을 더 쉽고 세련되게 제어할 수 있습니다. Suspense에 대한 자세한 내용은 [공식 문서](https://react.dev/reference/react/Suspense)나 [이 블로그 포스트](https://www.daleseo.com/react-suspense/)를 참고하세요.5:Tce5,
## 풀이

결국엔 어떻게 돌리느냐는 위 아래 눈이 무엇인지 가 중요 합니다.

내말은 돌려도 변하지 않는 면이 있는데, 그 면들을 중심으로 번호가 어떻게 변하는지 4개의 수의 반복이 어케되는지를 매겨놓으면 문제해결이 가능합니다.


처음 주사위 상태는

```
5 (굴려도 변하지 않는 앞쪽면)

1 (윗면)

2 (굴려도 변하지 않는 뒤쪽면)
```

이렇게 되고, 주사위를 굴리다가 다음 행으로 옮기게 되면 주사위의 상태는 아래처럼 변할 것입니다.

```
(마지막 윗면 상태 의 반대편)

(이전 윗면)

(마지막 윗면 상태)
```

또 그 다음은
```
(마지막 윗면 상태의 반대편)

N

(마지막 윗면상태)
```

이런식으로 반복됨을 알 수 있습니다.

그렇다면, 1 4 6 3과 같은 옆면의 수열을 어떻게 구할 수 있느냐가 이제 관건인데, 사실 주사위기 때문에 경우의 수가 그렇게 많지 않습니다.

저의 경우는 아예 계산을 해서 프리셋을 먼저 생성해놓고 풀었는데요, 아래와 같이 반복되는 수열이 정의됩니다.

*! 오른쪽으로 굴리는 기준 !*
```
(5, 2) 일 경우 {1, 4, 6, 3}
(2, 5) 일 경우 {1, 3, 6, 4}
(1, 6) 일 경우 {3, 2, 4, 5}
(6, 1) 일 경우 {3, 5, 4, 2}
(3, 4) 일 경우 {1, 5, 6, 2}
(4, 3) 일 경우 {1, 2, 6, 5}
```

## 구상한 알고리즘

### 행이 홀수일 경우

1. (a, b) 값을 얻는다. (이때 a와 b는 수열에 관여하지 않는 위에서 봤을때 기준 주사위의 앞, 뒷면 이다.)	

2. 이전 판의 a 값을 가져온다. 이 값이 현재 상태의 윗면이다.

3. 열의 크기를 4로 나눈 몫과 14(전체 수열의 투어 결과)를 곱한 값을 결과에 더한다.

4. 열의 크기를 4로 나눈 나머지값만큼 더 굴린다. `while(remain--) {}` 굴리는 원리는 첫 윗면의 idx 값을 가져와서, idx = (idx + 1) % 4; 와 같은 방식으로 더해나가면 된다.

### 행일 짝수일 경우

- 수열을 얻는 과정은 똑같이 진행하나, idx = (idx - 1 >= 0 ? idx - 1 : 3) % 4; 과 같이 전개하면 된다.

## 소스코드

```cpp
#include<iostream>
#include<vector>
using namespace std;

vector<int> preset[7][7];

int main() {
	int front = 5, back = 2;
	int up = 1;
	preset[5][2] = { 1, 4, 6, 3 };
	preset[2][5] = { 1, 3, 6, 4 };
	preset[1][6] = { 3, 2, 4, 5 };
	preset[6][1] = { 3, 5, 4, 2 };
	preset[3][4] = { 1, 5, 6, 2 };
	preset[4][3] = { 1, 2, 6, 5 };

	int n, m; cin >> n >> m;

	long long ans = 0;

	for (int i = 1; i <= n; ++i) {
		ans += (m / 4) * 14;
		int remain = m % 4;
		int idx = -1;
		
		for (int i = 0; i < 4; ++i) {
			if (preset[front][back][i] == up) {
				idx = i;
			}
		}

		while (remain--) {
			int next_value = preset[front][back][idx];
			ans += next_value;
			if (remain) {
				if(i%2) idx = (idx + 1) % 4;
				else idx = (idx - 1 >= 0 ? idx - 1 : 3) % 4;
			}
		}

		int tmp = front;
		back = preset[front][back][idx];
		up = tmp;
		front = 7 - back;
	}
	cout << ans;
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!6:T9df,
## 문제 접근

오프라인 쿼리라는 개념을 알고 접근해보도록 합시다.

오프라인 쿼리란 간략히 말해서, 쿼리의 전체 적용 결과 값**만** 알고 싶을 때 사용하는 전략으로,
쿼리의 순서를 모두 받은 뒤, 역순으로 처리할 때, 중복처리가 되지 않는 경우 그 점을 이용하는 전략입니다.

이 점을 이용해서 문제를 풀 수 있습니다.

## 솔루션

단, 위 개념을 알아도, 칠해져있는지 일일이 매 역순 쿼리마다 확인해나가다 보면 시간초과하기 마련입니다.

따라서 `space[1 to N]` 라는 이름의 배열을 생성하여 현재 위치를 기록해도 되는지, 그게 아니라면 다음 위치는 어디가 되는지를 기록해두어야합니다.

이를 구현한 방법은 분리집합에서의 `find()` 와 같습니다.

일단 매 쿼리에서 주어진 `l` 과 `r` 구간에서, 우리가 칠했던 모든 지역의 `space[]` 값을 `r + 1`로 설정해둡시다.

우리가 칠하는 지역의 `space[i]` 값이 `i`가 아닌 경우, 언급한 `find()` 함수를 통해 재귀적으로 호출하며 `space[]` 값을 갱신해나가면 최적화가 가능합니다.

## 소스코드

```cpp
#include<iostream>
#include<vector>
#include<utility>
using namespace std;

int space[1000001]; // 1 to 1m
int fibo[1000001]; // fibo value
int ind[1000001]; // answer which indicates index of fibo value.
const int MOD = 1000000007;

int find(int t) {
	if (space[t] == t) return t;
	return space[t] = find(space[t]);
}


int main() {
	cout.tie(0); cin.tie(0)->sync_with_stdio(0);

	fibo[1] = space[1] = 1;
	fibo[2] = space[2] = 2;
	
	for (int i = 3; i <= 1000000; ++i) {
		fibo[i] = fibo[i - 1] + fibo[i - 2];
		fibo[i] %= MOD;
		space[i] = i;
	}
	
	
	int n, q; cin >> n >> q;
	vector<pair<int,int>> query;
	space[n + 1] = n + 1;

	for (int i = 0; i < q; ++i) {
		int l, r; cin >> l >> r;
		query.push_back({l, r});
	}

	for (int i = query.size() - 1; i >= 0; --i) {
		int l = query[i].first;
		int r = query[i].second;
		int next = space[l];
		while (next <= n && next <= r) {
			next = find(next);
			if (next > r) break;
			int idx = next - l + 1;
			ind[next] = idx;
			space[next] = r + 1;
			next++;
		}
	}
	for (int i = 1; i <= n; ++i) {
		cout << fibo[ind[i]] << ' ';
	}
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!7:T104c,
## 내가 생각한 솔루션

### 1. 분리집합

문제를 보자마자 일단 아! 분리집합 문제구나 라고 생각은 했음.


각 영역의 분리집합을 구한 후, 분리집합의 개수 별로 nC2의 값을 표현하기 가 구현내용이 아닐지.. 하고.

예를들면, 문제 예시의 트리와, `K = 6, S_k = { 1,2,3,4,5,6 }` 인 경우

`{ 1, 2, 3, 5 }` 와 `{4, 6}`으로 두 영역이 나뉘므로,

`4C2 + 2C2 = 6 + 1 = 7` 가 정답인 것이다.

각 영역별로 수행한다고 치면 최악의 경우 O(N) 만큼 걸릴 것임.

이렇게 단순하게 생각하면 사실 풀 수 있지만, 애로사항이 있다.

위의 시간 복잡도는 정확하지 않다. **쿼리가 있기 때문이다.**

### 2. DFS

그래서 DFS로 해볼까? 하고 생각해봤다.

> S_K 마다 탐색을 한다.
>
> 자식노드가 없는 경우는 스킵한다.
>
> 이미 방문한 점도 스킵한다.

방문 수 : `O(N)` 이기 때문에 이 방법도 사실상 최적화엔 실패다.

## 해설을 통한 솔루션


위 방식대로하면 결국 각 노드에서 모든 간선 을 둘러보게 되는 단점이 있고, 이는 `O(N)` 만큼 소모되게 만드는 단점이 있다.

쿼리가 하나면 상관없지만 쿼리가 10만개나 되니, 결국 전체 쿼리에 등장하는 K의 개수가 최대 백만인 점을 이용해 `O(쿼리중 나오는 전체 K 집합의 원소 수)`로 단순화시켜야한다.

N의 크기에 영향을 받지 않고 순수하게 K만 살펴보기 위해서는 트리의 구조를 이용해야한다.

트리가 가지는 성질은 자신 노드가 루트가 아니라면, 부모노드는 오로지 하나라는 점이다.
이렇게 되면 순전히 K개의 노드와, 그의 부모노드만 확인하면 되게 되므로, `O(N + 쿼리중 나오는 전체 K집합의 원소 수)`가 되게 된다.

각 K의 부모노드를 확인해가면서, 분리집합으로 어떤 트리에 어떻게 속하는지 기록을 하며 루트노드가 될 노드에게 노드의 개수를 전달해주면 해결이다.

트리의 특성을 활용하는 문제였다. 많이 나에겐 어려운 것 같으니 골드 하위 트리문제를 좀 더 풀어봐야할 것 같다.

## 소스코드

`s[]` 배열을 `memset()` 을 통해 초기화 하지 않고, 쓰고 난 후 다시 `false` 값으로 되돌려 주면 AC 시간을 많이 단축 시킬 수 있습니다.

```cpp
#include<iostream>
#include<vector>
using namespace std;

vector<int> tree[250001];
bool visit[250001];
int parent[250001]; // 분리집합
int cnt[250001]; // 각 지점을 루트로 하는 트리의 노드 개수 입니다.
bool s[250001];
int tree_parent[250001];

void process(int node) {
	// dfs로 전처리 하는 과정
	visit[node] = true;
	for (int i : tree[node]) {
		if (!visit[i]) {
			process(i);
			tree_parent[i] = node;
		}
	}
}

int find(int t) {
	if (parent[t] == t) return t;
	return parent[t] = find(parent[t]);
}

void uni(int a, int b) {
	if (a > b) {
		int swp; swp = a; a = b; b = swp;
	}
	parent[b] = a;
	cnt[a] += cnt[b];
	cnt[b] = -1;
}

int main() {
	cin.tie(0); cout.tie(0)->sync_with_stdio(0);
	int n, q;
	cin >> n;
	for (int i = 0; i < n - 1; ++i) {
		int a, b; cin >> a >> b;
		tree[a].push_back(b);
		tree[b].push_back(a);
	}

	process(1); // 최소 노드의 개수는 1일테니 1을 루트로 정의한다.

	cin >> q;
	while (q--) {
		int k; cin >> k;
		vector<int> arr;

		for (int i = 0; i < k; ++i) {
			int t; cin >> t;
			parent[t] = t;
			cnt[t] = 1;
			s[t] = true;
			arr.push_back(t);
		}

		long long ans = 0;

		for (int t : arr) {
			if (s[tree_parent[t]]) {
				uni(find(t), find(tree_parent[t]));
			}
		}

		for (int t : arr) {
			s[t] = false; // 쓰고 바로 마킹을 지우면 memset을 할 필요가 없어짐.
			if (cnt[t] > 1) {
				ans += (long long)cnt[t] * (cnt[t] - 1) / 2;
			}
		}

		cout << ans << '\n';
	}
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!8:Tdca,
## 주의사항

본 문서는 Bing AI로 작성되었으며, 작성자 참고용으로 제작된 문서입니다. 향후 저작권 이슈가 있을 경우 바로 내릴 수 있도록 하겠습니다.

## 본문

TypeScript에서 as 키워드는 타입 단언(type assertion)을 사용하기 위한 것입니다. 타입 단언은 컴파일러에게 변수나 속성의 타입을 우리가 지정해주는 것이며, 컴파일러가 스스로 추론하는 것을 방지합니다. 타입 단언은 any 타입을 특정 타입으로 다루는 데 자주 사용됩니다. 예를 들어, 다음과 같은 코드가 있습니다.

```typescript
let x: any = "Hello";
let y = x as string;
```

여기서 `x`는 any 타입이므로, 컴파일러는 `x`가 가지고 있는 메서드나 속성에 대해 알 수 없습니다. 그래서 `x.length`나 `x.toUpperCase()`와 같은 코드는 오류를 발생시킬 수 있습니다. 하지만 `y`는 `x`를 string 타입으로 단언한 것이므로, 컴파일러는 `y`가 string 타입이라고 인식하고, string 타입의 메서드나 속성을 사용할 수 있습니다.

타입 단언은 변환(conversion)이 아닙니다. 즉, as 키워드로 변수의 값을 바꾸거나 새로운 값을 만들지 않습니다. 단지 컴파일러에게 변수의 타입을 알려주는 것뿐입니다. 런타임에는 as 키워드가 아무런 영향을 주지 않습니다¹.

타입 단언은 다음과 같은 두 가지 방식으로 사용할 수 있습니다.

```typescript
// 꺽쇠 괄호(<>)를 사용하는 방식
let a = <string> x;

// as 키워드를 사용하는 방식
let b = x as string;
```

두 방식은 동일한 기능을 하지만, JSX와 함께 사용할 때는 as 키워드를 사용해야 합니다². JSX는 XML과 비슷한 문법으로, React와 같은 프레임워크에서 UI 컴포넌트를 만들 때 사용합니다³.

## 타입에러 방지

타입 에러를 방지하기 위해서는 as 키워드를 사용하는 것이 좋지 않은 방법이라고 할 수 있습니다. as 키워드는 컴파일러에게 타입을 강제로 지정하는 것이므로, 실제로 값이 다른 타입일 경우 런타임에 에러가 발생할 수 있습니다. 예를 들어, 다음과 같은 코드가 있습니다.

```typescript
let x: any = 123;
let y = x as string;
console.log(y.length); // 런타임 에러
```

여기서 `x`는 any 타입이므로, `y`에 string 타입으로 단언하였습니다. 하지만 `x`의 값은 실제로 숫자이므로, `y.length`를 실행하면 런타임에 에러가 발생합니다. 이런 경우를 방지하기 위해서는 as 키워드를 사용하지 않고, 타입 가드(type guard)라는 기능을 사용하는 것이 좋습니다¹. 타입 가드는 특정 조건문을 통해 변수의 타입을 좁혀주는 것입니다. 예를 들어, 다음과 같은 코드가 있습니다.

```typescript
let x: any = 123;
// string이 타입이 아닌 문자열임에 주의하세요. (코멘트 직접 작성)
if (typeof x === "string") {
  console.log(x.length); // 안전하게 실행
}
```

여기서 `typeof x === "string"`이라는 조건문은 `x`가 string 타입일 때만 참이 되므로, 컴파일러는 이 조건문 안에서 `x`의 타입을 string으로 인식합니다. 따라서 `x.length`를 안전하게 실행할 수 있습니다.

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!9:T1287,
드로우 온 웹 프로젝트를 현재 `vite + react + typescript`로 진행중입니다.

하다가 문제점이 생긴게, 캔버스 토글을 `animation`을 주면서 껐다켰다하는 기능을 만드는 중이넫 여기서 문제가 생기더라고요

`eventlistener` 를 삭제하려면 해당 함수가 무결해야 하고, 함수가 특정 변수에 정의되어 있어 지정할 수 있어야합니다..

그런데, 제가 마우스 이벤트를 사용하던 함수들은 모두 리액트 훅으로 반환되는 `ref` 객체를 사용하고 있었습니다...

이렇게 되면 해당 함수들을 모두 `toggleCanvas` 내에 정의를 해야하는데, 그렇게되면 함수가 너무 길어져서 코드의 가독성이 작살나버리더라고요.

```ts
function toggleCanvas(params:toggleCanvasParams) {
  const {ctx, status} = params;
  const prevX = useRef<number>(0);
  const prevY = useRef<number>(0);

  const contextMenuTimer = useRef<number>(0);
  const pressed = useRef<boolean>(false);

  if (status) {
    ctx.canvas.classList.add("hide-canvas");
    // first click events
    window.addEventListener("mousedown", (e) => {
      if (e.button != 2) return;
      pressed.current = true;
      prevX.current = e.pageX;
      prevY.current = e.pageY;
    });

    // mouse release events
    window.addEventListener("mouseup", (e) => {
      if (e.button != 2) return;
      pressed.current = false;
    });

    // drawing events.
    window.addEventListener("mousemove", (e) => {
      if (!pressed.current) return;
      if (!ctx) return;
      contextMenuTimer.current++;
      doBrush(ctx, prevX, prevY, e);
    });

    // about context menu popup
    window.addEventListener("contextmenu", (e) => {
      if (contextMenuTimer.current >= 10) e.preventDefault();
      contextMenuTimer.current = 0;
    });
  } else {
    ctx.canvas.classList.add("hide-canvas");
    // 여기선 어떻게 해야하지?!
  }
}
```

## 내가 해결한 방법

위와 같은 방법으로 해도 removeEventListener는 동작하지 않습니다.

removeEventListener를 사용하기 위해선 함수가 한번만 정의되어야합니다.

따라서,

1. 중첩함수 (함수가 호출될때마다 정의됨)
2. 익명함수 (함수가 메모리에 매번 새롭게 assign됨)

는 사용할 수 없습니다.

클로저를 이용하여 전역에 접근할 EventContext 클래스를 정의하고, 함수들 또한 전역 스코프에 선언해주어 유일한 객체로 만들어야합니다.

아래는 예시입니다.

```ts
// 이벤트 객체에 클로저로 직접 주입한 객체. 근데 이게 맞는지 모르겠다.
class EventContext {
  static params: toggleCanvasParams;
  static setParam(params:toggleCanvasParams): void {
    EventContext.params = params;
  }
}

function doBrush(params: doBrushParams) { ... }


function handleMouseDown(e: MouseEvent) {
  const {pressed, prevX, prevY} = EventContext.params;
  if (e.button != 2) return;
  pressed.current = true;
  prevX.current = e.pageX;
  prevY.current = e.pageY;
}

function handleMouseUp(e: MouseEvent) {
  const {pressed} = EventContext.params;
  if (e.button != 2) return;
  pressed.current = false;
}

function handleMouseMove(e :MouseEvent) {
  const {pressed, contextMenuTimer, ctx, prevX, prevY} = EventContext.params;
  if (!pressed.current) return;
  contextMenuTimer.current++;
  doBrush({ctx, prevX, prevY, event:e});
}

function handleRightClick(e: MouseEvent) {
  const {contextMenuTimer} = EventContext.params;
  if (contextMenuTimer.current >= 10) e.preventDefault();
  contextMenuTimer.current = 0;
}

export function toggleCanvas(params:toggleCanvasParams) {
  EventContext.setParam(params);
  const {ctx, status} = params;

  if (status) {
    ctx.canvas.classList.remove("hide-canvas");

    window.addEventListener("mousedown", handleMouseDown);
    window.addEventListener("mouseup", handleMouseUp);
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("contextmenu", handleRightClick);

  } else {
    ctx.canvas.classList.add("hide-canvas");
    
    window.removeEventListener("mousedown", handleMouseDown);
    window.removeEventListener("mouseup", handleMouseUp);
    window.removeEventListener("mousemove", handleMouseMove);
    window.removeEventListener("contextmenu", handleRightClick);
  }
}
```

여기서 더 나아가서 핸들러들을 EventContext의 메소드로 선언해도 가능한지 한번 연구중에 있습니당

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!a:T827,
## 나의 접근

이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데
도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다...

스택의 특징을 아직 잘 몰라서 실수를 했는데, 스택이 사용될 수 있는 상황은 다음과 같습니다.

- 현재 문제 상황이 선형적이지만, 여태까지 내가 "탐색"했던 정보들을 바탕으로 판단해야할 때,

- 혹은 탐색했지만 정답을 찾지못한 정보들을 모아두었다가 나중에 일괄적으로 문제를 해결할 수 있을 때,

- 그 외 느낌상으로 모아두었다가 해결할 수 있을 것 같을 때

한번 쯤 생각해보면 좋을 것 같습니다. 스택..실제로 활용 문제를 실전풀이로 할 때 상당히 어려운 것 같습니다.

## 알고리즘

1. 현재 수를 보고 다음 수를 본다, 다음 수가 더 크다면, 기본적으로 현재 수의 NGE는 다음 수이다.

2. 만약 다음 수가 더 작다면, 현재수를 push 하고 다음 수를 본다.

3. 1의 과정 중, 다음 수가 현재수보다 크다면, 현재 수의 NGE는 다음 수 이다, 또한 스택이 비지 않았을 때, top이 현재 시점의 다음 수보다 작을 경우, 해당 수의 NGE도 현재 시점의 다음 수이다.

## 소스코드

```cpp
#include<iostream>
#include<stack>
#include<vector>
using namespace std;

int main() {
	cout.tie(0); cin.tie(0)->sync_with_stdio(0);
	int n; cin >> n;
	vector<int> arr(n);
	vector<int> ans(n, -1);
	stack<int> st;

	for (int i = 0; i < n; ++i) {
		cin >> arr[i];
	}
	
	for (int i = 0; i < n - 1; ++i) {
		if (arr[i + 1] > arr[i]) {
			ans[i] = arr[i + 1];
			while (!st.empty() && arr[st.top()] < arr[i + 1]) {
				ans[st.top()] = arr[i + 1];
				st.pop();
			}
		}
		else if (arr[i + 1] <= arr[i]) {
			st.push(i);
		}
	}
	for (int t : ans) {
		cout << t << ' ';
	}
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!b:T598,
### 소스 코드

```cpp
#include<iostream>
using namespace std;

int n, k, l;
string input;

int u[10001][10001];
int dp[10001]; // 유사 펠린드롬의 여부 = 1 이상이면 해당, 또 1 이상인 값이 여러개 일 경우 가장 적은 값 입니다.

int getU(int s, int e) {
	if (s >= e) return 0;
	if (u[s][e]) return u[s][e];
	if (input[s] != input[e]) return 0;
	return u[s][e] = 1 + getU(s + 1, e - 1);
}

bool is_theta(int s, int e) {
	if (s == e) return false;

	int len = e - s + 1;
	int v_len = getU(s, e);

	if (k*len <= 2 * v_len * l) return true;
	return false;
}

int main() {
	cin >> n >> k >> l >> input;

	for (int i = 0; i < n; ++i) {
		dp[i] = -1;

		if (is_theta(0, i)) dp[i] = 1;

		for (int j = 1; j < i; ++j) {
			// 끝점이 i인 경우를 모두 검색하다보면 dp 값을 한번만 방문할 수 있을 것이다.
			// 1 ~ j / j + 1 ~ i 이렇게 두개로 나눔.
			// 더 작은 segment로 나뉠 수 있는 것 아닌가? -> 그 경우는 이미 dp[a][b] : b가 i보다 작은 경우에서 모두 구했음.
			if (is_theta(j, i) && dp[j - 1] > 0) {
				if (dp[i] > 1 + dp[j - 1] || dp[i] == -1) {
					
					dp[i] = dp[j - 1] + 1;
				}
			}
		}
	}
	
	cout << ((dp[n - 1] == -1) ? 0 : dp[n - 1]);
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!c:T1874,
## 접근


처음 접근은 이랬습니다. 사실 제일 처음에 어려웠던 부분은 d-정상이 무엇인지 이해를 하는 것이였습니다.

d만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데,
잘못된 방법이였습니다.

땅에서부터 d 만큼의 높이차가 존재하는 지역이 정상이라고 생각할 수 없는 이유는, 해당하는 높은 지역 사이에 그 지역보다 더 높은 지역이 있을지도 모르기 때문입니다.

예를들어, 해당 지점이 땅이 아닌 지점이면서 (h-d)보다 더 낮은 지점이 방문 가능한 봉우리 h가 있다고 하면 어떻게 될까요?

그림으로 설명해보겠습니다.

```
- 제일 높은 위치 (0)
			            ---           ==> 여긴 d 정상임 (1)
		                | -> d보다 작음
            ------  ===========> 여긴 d 정상이 아님. (2)
            | -> d보다 큼.
---- 땅 -
```

```
1
2 4 2
5 0 3 4
```

가장 높은 지점에서만 bfs하면  (1)이 d-정상임을 판별할 수 없고,

땅에서부터 bfs하면 (2)가 d-정상이 아님을 판별할 수 없습니다.

따라서 저희는 모든 점을 찾아볼 수 밖에 없습니다.

다만, 그중에서 가장 높은 "정상"부터 BFS해야합니다. d-정상의 정의에 따르면 높이가 어떻든, 가장 높은 점은 자신보다 더 높은 점이 존재하지 않기 때문에 주어진 맵에서 가장 높은 높이를 부여받은 지점은 무조건 d-정상에 해당됩니다.

일단 가장 높은 지점에서부터 높이차가 d보다 작은 지점들을 bfs 하면서 visit 을 했다는 표식을 남깁시다.

이 표식이 그 다음으로 가장 높은 지점에서  높이차가 d보다 작은 지점들을 bfs를 하다가 사전에 방문했던 지점들을 만난다면, 그것은 d-정상의 정의에 위배됩니다. 따라서 해당 bfs시작점을 비롯한 bfs 중 만났던 해당 bfs 시점 중 가장 높은 지점들 전부 d-정상에 위배됩니다.

현재 bfs 중 방문햇던 지점과, 이전에 이미 방문했었던 지점을 구별하기 위해 `visit` 값은 `bool`이 아닌 `int` 값을 사용했습니다.

## 구현

1. 가장 높은 지역을 BFS 한다.

2. 닿지 않는 지역 중 그다음으로 가장 높은 지역을 BFS 한다. // 각 세그 먼트 중 자신보다 높은 지역이 닿이는 세그먼트는 d 정상이 아니다.

3. `queue`를 sorting 할거면.. `priority queue`를 사용.

PQ를 사용한 뒤, 일단 visit 배열을 정상값으로 칠합니다. 이게 무슨 소리냐면, 3 이 정상이라 하면, 최소 (3 - d)인 지점을 모두 bfs 해가며 해당 부분의 visit 값은 가장 높은 정상의 값으로 정한다는 뜻입니다.

만약 해당 bfs segment 도중에 자신보다 높은 지점을 나타내는 , 해당 bfs 서브프로세스에서 얻는 d-정상의 개수는 무조건 0으로 합니다. 단, 추후 bfs 할 프로세스에서 가장 높은 h는 현재의 h보다 작기 때문에 bfs 세그먼트를 계속해야합니다.

도중에 자신과 같은 높이의 지점을 만났다면 bfs segment 에서 더할 d-정상의 개수를 1 늘립니다.

도중에 라벨된 지점을 만났다면 해당 segment에서 얻는 d-정상의 개수는 0입니다. 왜냐하면 지점이 높은순으로 라벨링을 했기 때문입니다.

## 내가 계속 틀렸던 이유

### board를 클리어하지 않아서 계속 틀렸었다.

이때 `vector`를 써야하는 이유를 알았습니다.

vector 가 갖는 또 다른 이점은 로컬 변수로 선언함으로써 반복문 내에서도 부담없이 memset할 필요가 없었고, 무엇보다 스택 영역을 차지하지 않음으로써 스택오버플로우도 면할 수 있었습니다. 여러모로 상당히 고마운 존재입니다.

### board[n+2][m+2] 와 같은 형식으로 구현하고자 하는 경우

이럴땐 board[][]의 경계선을 확실히 해주도록합시다. 문제에선 0이 가장 낮은 땅이므로 경계선과 땅을 구별할 수 없습니다.

따라서 입력된 board[][] 값을 모두 1씩 올려줌으로써 해결했습니다.


## 소스코드

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
typedef pair<int, int> pii;

int board[502][502];
int visit[502][502] = { 0, };
int dir[4][2] = {
	{0, 1},
	{0, -1},
	{1, 0},
	{-1, 0}
};

int n, m, d, total;
priority_queue<pair<int, pii>> pq;
queue<pii> bfs_q;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	while (t--) {
		total = 0;
		cin >> n >> m >> d;
		for (int i = 0; i <= n + 1; ++i) {
			memset(visit[i], 0, sizeof(visit[i]));
			memset(board[i], 0, sizeof(board[i]));
		}

		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= m; ++j) {
				cin >> board[i][j];
				board[i][j]++;
				if (board[i][j]) {
					pq.push({ board[i][j], {i, j} });
				}
			}
		}

		int visit_seg = 0;

		while (!pq.empty()) {
			int d_summit = 1;
			visit_seg++;
			int h = pq.top().first;
			int st_x = pq.top().second.second;
			int st_y = pq.top().second.first;
			pq.pop();

			if (visit[st_y][st_x]) continue;
			visit[st_y][st_x] = visit_seg;

			bfs_q.push({ st_y, st_x });

			while (!bfs_q.empty()) {
				int y = bfs_q.front().first;
				int x = bfs_q.front().second;
				bfs_q.pop();

				for (int i = 0; i < 4; ++i) {
					int dy = y + dir[i][0];
					int dx = x + dir[i][1];

					if (!board[dy][dx]) continue;

					if (visit[dy][dx] && visit[dy][dx] < visit_seg) {
						d_summit = 0;
						continue;
					}

					if (visit[dy][dx] == visit_seg) continue;

					if (board[dy][dx] == h) {
						if (d_summit) d_summit++;
					}

					if (!visit[dy][dx] && board[dy][dx] > h - d) {
						visit[dy][dx] = visit_seg;
						bfs_q.push({ dy, dx });
					}
				}

			}

			total += d_summit;
		}

		cout << total << '\n';
	}
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!

d:T13b8,
## `next_permutation()` 이란?

알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다. 물론 
이런 경우는 사실 대부분 재귀함수를 사용하다보면 해결이 되는 경우가 많습니다.

하지만 재귀를 통한 경우의 수 추출의 경우, 모든 경우의 수의 처리를 위해서는 해당 함수 호출스택 내에서 외부 변수에 모두 모아놓거나, 각각의 경우의 수가 완성된 경우의 함수 스택 상태 위에서 작업을 실행해야 모든 경우의 수에 대한 대응이 가능합니다.

간단한 처리의 경우는 상관 없지만, `스택 오버플로우` 와 같은 오류를 내고 싶지 않은 상황이거나 재귀 함수를 사용 하는 것에 대해 약간 민감한 상황이라면, `next_permutation` 을 사용하는 것이 좋다고 생각합니다.

`next_permutation()` 함수는 `algorithm` 내 헤더에 있으며, 보통은 함수의 인자로 `iterator` 의 처음 부분과 끝 부분을 넣습니다.

이때 `iterator` 의 개념에 대해 간단히 이야기하자면, 그냥 배열의 요소를 가르킨다고 보시면 됩니다. `C++`을 알고리즘 문제풀이로 사용하는 입장에서는 일반적인 배열과 `vector` 의 처음과 끝 포인터가 들어간다고 생각하면 됩니다.

해당 함수가 호출되면, 함수의 인자로 들어간 `배열 객체의 다음 순열의 순서`로 변경해줍니다. 이때 정의된 배열의 순열의 순서는 오름차순이 기준입니다.

예를 들어, `0 0 1` 의 순열을 오름차순으로 나열하였을 때, 해당 배열의 다음 순열은 `0 1 0` 일 겁니다. 그 다음은 `1 0 0` 일 것입니다.

따라서 보통 일반적으로 `next_permutation()`을 호출하기 전에 오름차순에 따라 **정렬을 해두고 사용 해야 모든 순열의 경우의 수를 확인할 수 있습니다.**

## 조합을 뽑는 방법

`next_permutation` 에서는 값이 같은 배열의 요소를 동일한 원소로 취급합니다. 이 점을 이용하여 조합을 만들 수도 있습니다.

이게 무슨 뜻이냐면, `0(1번째 원소) 0(2번째 원소) 1` 이라는 내용의 배열이 있다면, `0` 두개가 동일원소로 취급되지 않는 중복 순열 이라면 다음 순열은 `0(2번째 원소) 0(1번째 원소) 1` 이 다음 순열이여야합니다. 하지만 `next_permuation` 에서는 중복을 허용하지 않는 순열을 반환하기 때문에 중복 원소에 대한 순열은 스킵이 됩니다.

이를 통해 조합을 구성하는 방법은 간단합니다. 뽑는가, 뽑지 않는가 여부만 판단하는 것이 조합이므로, 뽑는 수만큼 `1`, 뽑지 않는 수만큼 `0`으로 구성된 0-1 배열을 구성하여 `next_permutation` 함수를 호출 하면, 모든 조합의 경우의 수를 알 수 있습니다.

## 응용

해당 문제는 응용입니다. 문제를 풀고 밑부분을 참고하세요.

- [[ 백준 18809 ] Gaaaaarden : C++ 풀이](https://chayhan.github.io/markdown-blog/2023-10-20-boj18809)


### 활용 설명

위에서 조합을 응용하는 방법은 그렇습니다.

조합을 두번 뽑지 않고, 중복순열이 아닌 점을 활용하는 겁니다.

땅이 5개, 그중에 빨간 배양액 2곳과 초록 배양액 2곳을 사용한다고 하는 예제 입력이 있다고 합시다. 그런 경우에 `0 1 1 2 2` 와 같은 배열의 순열을 순회하면 배양액을 뿌리는 모든 경우의 수를 저희는 확인할 수가 있을 것입니다.

위와 같은 방식으로 문제를 활용할 수도 있을 것입니다.

## 코드 짜는 법

이제부터는 실제 코드 사용법에 대해 알아보겠습니다.

익숙치 않는 문법을 사용할 건데요. `do - while` 문을 사용할 것입니다. 그것에는 이유가 있습니다. `sort` 를  통해 순열을 확인할 배열을 정렬했다면, 일단 맨 첫번째 순열은 이미 정렬된 해당 배열이기 때문에 해당 구문을 이용해 일단 확인해도 모든 경우의 수를 확인할 수 있기 때문입니다.

`while`문의 조건 문에서 next_permutation()을 호출하면 현재 해당 배열이 마지막 순열( = 현재 배열이 내림차순인지)인지 아닌지에 따라 `return` 값이 달라집니다.

마지막 순열이라면 false를 출력하기 때문에 순열을 순회하기도 쉽습니다.

1. 배열 구성하기
2. `sort` 하기
3. `do - while` 구문으로  순회하기

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main() {
    int arr[5];
    for (int i = 0; i < 5; ++i) {
        arr[i] = i + 1;
    }
    sort(arr, arr + 5);
    do {

        for (auto i : arr) {
            cout << i << ' ';
        }
        cout << '\n';
    } while (next_permutation(arr, arr + 5));
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!e:T932,### 소스코드

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

int n, m;
int r, g;
int board[52][52]; // 맵

vector<pair<int, int>> able_list; // 배양액 뿌릴 수 있는 땅 정보

int dir[4][2] = {
	{0, 1},
	{1, 0},
	{0, -1},
	{-1, 0}
};

int flowers; // 꽃의 개수

void bfs(vector<pair<int, int>>& gv, vector<pair<int, int>>& rv) {
	int visit[52][52] = { 0, }; // 빨간색 -t 값. 초록색 t 값으로 시간을 표현. 1초부터 시작. 0이면 닿지않은 경우임.
	int f = 0; // 현재 꽃
	queue<pair<int, pair<int, int>>> q; // bfs q

	for (auto t : gv) {
		visit[t.first][t.second] = -1;
		q.push({ -1, t });
	}

	for (auto t : rv) {
		visit[t.first][t.second] = 1;
		q.push({ 1, t });
	}

	while (!q.empty()) {
		int time = q.front().first;
		pair<int, int> node = q.front().second; q.pop();

		int y = node.first;
		int x = node.second;

		if (visit[y][x] == 9999) continue; // 꽃은 퍼지지 않음.

		visit[y][x] = time;

		if (time > 0) time++;
		else time--;

		for (int i = 0; i < 4; ++i) {
			int dy = y + dir[i][0];
			int dx = x + dir[i][1];

			if (visit[dy][dx] + time == 0) {
				visit[dy][dx] = 9999;
				f++;
				continue;
			}

			if (board[dy][dx] && visit[dy][dx] == 0) {
				q.push({ time, {dy, dx} });
				visit[dy][dx] = time;
			}
		}
	}
	flowers = flowers < f ? f : flowers;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m >> r >> g;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			cin >> board[i][j];
			if (board[i][j] == 2) {
				able_list.push_back({ i, j });
			}
		}
	}


	vector<int> p;
	for (int i = 0; i < able_list.size() - r - g; ++i) p.push_back(0);
	for (int i = 0; i < r; ++i) p.push_back(1);
	for (int i = 0; i < g; ++i) p.push_back(2);

	do {

		vector<pair<int, int>> r_list;
		vector<pair<int, int>> g_list;

		for (int i = 0; i < p.size(); ++i) {
			if (p[i] == 1) r_list.push_back(able_list[i]);
			if (p[i] == 2) g_list.push_back(able_list[i]);
		}

		bfs(g_list, r_list);

	} while (next_permutation(p.begin(), p.end()));

	cout << flowers;
}
```

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!f:T93f,## 이미지 가져오기

이미지를 가져오는 건 리액트처럼 그냥 해당  프로젝트 내에서도 가져올 수 있는데 문제는 asset들은 모두 `public` 폴더 를 root로 하기 때문에 해당 폴더 내에만 배치를 해야한다.

본 문서들도 모두 public 에 배치된 이유가 그렇기 때문이다.

## 동적 라우팅

동적 라우팅은 app router 에서는 이전 레거시 버전처럼 폴더 이름의 양 끝을 대괄호로 감싼 다음, 그 안의 `page.ts` 에서 `params` 라는 속성을 받게 만든다면 알아서 서버 컴포넌트에서 params 에 폴더 이름에 대응하는 값을 params 에 해당 폴더 이름으로 속성으로 넣어준다.

## 페이지의 타이틀 변경

타이틀 부분은 중요하다.

같은 솔루션 페이지를 여러군데를 띄워놓앗을 때 어떤 탭의 페이지가 어떤 내용을 함축하고있는지 나타내주어야하는데 가장 간단한 방법이 타이틀을 바꾸는 방법이다. 

- 해결방법 : `<Head>` 기능을 사용하면 된다.

일단 아래처럼 가져온다.

```js
import Head from 'next/head'
```

그런데 알고보니 이게 app router 에서는 이렇게 사용하지 않는다고 한다.

![Alt text](image.png)

해결방법은 아래와 같이 Metadata 값을 재정의 해주는 것만으로 새롭게 바뀌는 가보다. 작동방식이 상당히 특이하다. 아마 해당 Functional Component의 default export 값만 보는게 아닌 것 같다.

![Alt text](image-1.png)

## Typescript on React : 자식 설정

`This JSX tag's 'children' prop expects a single child of type 'ReactElement<any, string | JSXElementConstructor<any>>', but multiple children were provided.`

위와 관련된 에러 해결이다.

아래와 같이 설정하자.

```js
children: JSX.Element|JSX.Element[];
```

### Typescript 에서 React Children 설정 방법

총 3가지가 있음.

- React.ReactNode
- JSX.Element 
- React.ReactElement


이렇게 3가지가 있는데, React.ReactNode를 사용하면 `string`, `number`를 비롯한 JSX 노드들을 중복/단일 상관없이 받기 때문에, `React.ReactNode` 를 사용하면 됩니다.

> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!0:["BbcWSzB1_QGqJkRFhNMxb",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],["",{"children":["__PAGE__",{},["$L1",["$","div",null,{"className":"page_mainWrap__G2_gf","children":[["$","div",null,{"className":"page_title__3jonF","children":"Posts"}],["$","div",null,{"className":"page_description__86bsR","children":"다양한 주제로 글을 씁니다."}],["$","div",null,{"className":"page_hr__LC6V_"}],["$","$2",null,{"fallback":"loading...","children":["$","$L3",null,{"articleList":[{"slug":"2023-12-25-darkmode-flickering","content":"$4","title":"다크모드 테마 시 깜빡거리는 증상","date":"$D2023-12-25T00:00:00.000Z","description":"내가 시스템에서 설정한 테마 색이 먼저 적용이 되고, 그 다음에 다크 모드로 설정된 테마가 나중에 적용되는 현상","dateString":"Dec 25, 2023"},{"slug":"2023-11-16-boj2818","content":"$5","title":"[ 백준 2818 ] 숙제하기 싫을 때 : C++ 풀이","date":"$D2023-11-16T00:00:00.000Z","description":"백준 2818 풀이입니다.","dateString":"Nov 16, 2023"},{"slug":"2023-11-16-boj26087","content":"$6","title":"[ 백준 26087 ] 피보나치와 마지막 수열과 쿼리 : C++ 풀이","date":"$D2023-11-16T00:00:00.000Z","description":"백준 26087 풀이입니다.","dateString":"Nov 16, 2023"},{"slug":"2023-11-15-text-underline","content":"\r\ntext-underline의 상세한 조절이 가능합니다.\r\n\r\n## underline의 굵기 설정\r\n\r\n```css\r\ntext-decoration-thickness: 0;\r\n```\r\n\r\n## underline의 위치 조절\r\n\r\n```css\r\ntext-underline-offset: 5px;\r\n```\r\n\r\n참고할 수 있도록 게시함.\r\n\r\n> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!","title":"[ CSS ] text underline 의 높이 조절, 굵기 설정하기","date":"$D2023-11-15T00:00:00.000Z","description":"text-underline의 상세한 스타일을 조절할 수 있습니다.","dateString":"Nov 15, 2023"},{"slug":"2023-11-12-query-tree","content":"$7","title":"[ 백준 25402 ] 트리와 쿼리 : C++ 풀이","date":"$D2023-11-12T00:00:00.000Z","description":"트리의 특성을 이용한 연결그래프 탐색문제입니다.","dateString":"Nov 12, 2023"},{"slug":"2023-11-03-typescript-interface","content":"$8","title":"[ TS ] 타입스크립트에서 타이핑 하기 귀찮은데요 (Typescript as 키워드)","date":"$D2023-11-03T00:00:00.000Z","description":"TypeScript에서 as 키워드는 타입 단언(type assertion)을 사용하기 위한 것입니다.","dateString":"Nov 3, 2023"},{"slug":"2023-10-31-remove-event","content":"$9","title":"[ React ] 이벤트 탈착할 때 주의 사항","date":"$D2023-10-31T00:00:00.000Z","description":"드로우 온 웹 크롬 익스텐션 사이드 프로젝트 중에 생긴 문제입니다.","dateString":"Oct 31, 2023"},{"slug":"2023-10-25-boj17298","content":"$a","title":"[ 백준 17298 ] 오큰수 : C++ 풀이","date":"$D2023-10-25T00:00:00.000Z","description":"이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데 도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다.","dateString":"Oct 25, 2023"},{"slug":"2023-10-24-boj13330","content":"$b","title":"[ 백준 13330 ] 유사 팰린드롬 : C++ 풀이","date":"$D2023-10-24T00:00:00.000Z","description":"소스코드만 있습니다.","dateString":"Oct 24, 2023"},{"slug":"2023-10-23-boj3697","content":"$c","title":"[ 백준 3697 ] 정상 : C++ 풀이","date":"$D2023-10-23T00:00:00.000Z","description":"d만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데, 잘못된 방법이였습니다.","dateString":"Oct 23, 2023"},{"slug":"2023-10-21-next-permutation","content":"$d","title":"[ C++ ] 조합, 순열 을 next_permutation() 으로 순회하기","date":"$D2023-10-21T00:00:00.000Z","description":"알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다.","dateString":"Oct 21, 2023"},{"slug":"2023-10-20-boj18809","content":"$e","title":"[ 백준 18809 ] Gaaaaarden : C++ 풀이","date":"$D2023-10-20T00:00:00.000Z","description":"소스코드만 있습니다.","dateString":"Oct 20, 2023"},{"slug":"2023-10-14-lis","content":"## 풀이\r\n\r\n풀이는 제 이전 블로그에서 확인 가능합니다.\r\n\r\n## [소스코드 : LIS 3](https://boj.kr/12783)\r\n\r\n```cpp\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint n, len;\r\n\r\nint arr[1000000];\r\nint lis[1000000];\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tcin >> n;\r\n\r\n\tfor (int i = 0; i < n; ++i) cin >> arr[i];\r\n\r\n\tlen = 1;\r\n\tlis[0] = arr[0];\r\n\t\r\n\tfor (int i = 1; i < n; ++i) {\r\n\t\tint l = 0;\r\n\t\tint h = len;\r\n\t\tint upper_bound = h;\r\n\r\n\t\twhile (l <= h) {\r\n\t\t\tint mid = (l + h) / 2;\r\n\t\t\tif (lis[mid] < arr[i]) {\r\n\t\t\t\tl = mid + 1;\r\n\t\t\t}\r\n\t\t\telse if (lis[mid] >= arr[i]) {\r\n\t\t\t\tupper_bound = mid;\r\n\t\t\t\th = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlis[upper_bound] = arr[i];\r\n\t\tif (len == upper_bound) {\r\n\t\t\tlen += 1;\r\n\t\t}\r\n\r\n\t}\r\n\tcout << len;\r\n}\r\n```\r\n\r\n## 주의점\r\n\r\n### `upper bound`를 확실히 구할 것!\r\n\r\n해당 값을 제대로 구했는지 확인할 요소\r\n\r\n1. `while(lo < hi)` 가 아니라 `while(lo <= hi)` 인지\r\n\r\n```\r\n7\r\n4 5 6 1 2 3 4\r\n\r\n정답 : 4\r\n```\r\n\r\n> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!","title":"LIS 알고리즘 개념","date":"$D2023-10-14T00:00:00.000Z","description":"풀이는 제 이전 블로그에서 확인 가능합니다.","dateString":"Oct 14, 2023"},{"slug":"2023-10-12-nojekyll","content":"# `.nojekyll` 설정하기\r\n\r\n이거 때문에 하루를 날려먹었다.\r\n\r\n`gh-pages` 를 통해 호스팅하는 모든 페이지들은 `jekyll` 블로그 설정에 따라 호스팅 되는 경우가 많아, 깃허브에서\r\n자체적으로 `_next` 와 같은 디렉토리를 차단시켜버리는 경향이 있습니다.\r\n\r\n이를 막기위해서 gh-pages에 deploy할 branch의 루트폴더에 `.nojekyll` 이라는 이름의 파일을 두어 깃허브가\r\n해당 정적페이지는 제킬이 아님을 알려주어야 인식이 정상적으로 된다.\r\n\r\n> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!","title":"깃허브 페이지에서 _next/ 폴더에 접근할 수 없는 경우","date":"$D2023-10-12T00:00:00.000Z","description":".nojekyll 설정하기","dateString":"Oct 12, 2023"},{"slug":"2023-10-12-boj11401","content":"## 설명\r\n\r\n일단 이 문제를 풀기 위해선 `페르마의 소정리`와 `모듈러 역원`을 구하는 연산을 할줄 알아야한다.\r\n\r\n\r\n\r\n### 소스코드\r\n\r\n```cpp\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint n, r;\r\nint fact[4000001];\r\nconst long long MOD = 1000000007;\r\n\r\nlong long getFact(long long n) {\r\n\tif (n == 0) return 1;\r\n\tif (fact[n]) return fact[n];\r\n\treturn fact[n] = n * (long long)getFact(n - 1) % MOD;\r\n}\r\n\r\nlong long power(long long base, int exp) {\r\n\tif (!exp) return 1;\r\n\tlong long i = 1;\r\n\twhile (exp) {\r\n\t\tif (exp % 2) {\r\n\t\t\ti *= base;\r\n\t\t\ti %= MOD;\r\n\t\t\texp--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tbase *= base;\r\n\t\tbase %= MOD;\r\n\t\texp /= 2;\r\n\t}\r\n\treturn i;\r\n}\r\n\r\nint main() {\r\n\tcin >> n >> r;\r\n\tlong long numer = getFact(n);\r\n\tlong long deno = getFact(r) * getFact(n - r) % MOD;\r\n\tdeno = power(deno, MOD - 2);\r\n\tnumer = numer * deno % MOD;\r\n\tcout << numer;\r\n}\r\n```\r\n\r\n> 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!","title":"[ 백준 11401 ] 이항 계수 3 : C++ 풀이","date":"$D2023-10-12T00:00:00.000Z","description":"일단 이 문제를 풀기 위해선 페르마의 소정리와 모듈러 역원을 구하는 연산을 할줄 알아야한다.","dateString":"Oct 12, 2023"},{"slug":"2023-10-11-next-js-blog","content":"$f","title":"[Next.js] 블로그 만들 때 생긴 에러 해결방안들 임시 메모","date":"$D2023-10-11T00:00:00.000Z","description":"이미지 가져오기, 동적 라우팅, 페이지 타이틀 변경 등","dateString":"Oct 11, 2023"},{"slug":"2023-10-11-hello-world","content":"\r\n# 제목1\r\n\r\n## 제목 2\r\n\r\n### 제목 3\r\n\r\n#### 제목 4\r\n\r\n> 인용 태그\r\n\r\n안녕하세요.\r\n\r\n`Code`\r\n\r\n```cpp\r\nprintf(\"code\");\r\n```\r\n\r\n[link](\"/\")\r\n\r\nanything else?\r\n\r\n블로그의 탄생을 축하하며.","title":"Hello, World!","date":"$D2023-10-11T00:00:00.000Z","description":"블로그의 탄생을 축하하며.","dateString":"Oct 11, 2023"},{"slug":"2023-10-11-disjoint-set","content":"분리집합의 구현에 관해서는 `union-find` 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.\r\n\r\n문제를 풀다가 이번에도 같은 방식으로 틀려서 기록하게 되었다.\r\n\r\n```cpp\r\nparent[t1] = p2;\r\n```\r\n\r\n위와 같이 바꾸게 되면, t1의 부모까지 부모값이 p2로 갱신되지 않고 짤리므로 위와 같이 구현하면 안된다.\r\n\r\n따라서 아래와 같이 그냥 부모노드의 부모값을 바꿔주어야한다.\r\n\r\n```cpp\r\nint t1 = edges[i - 1].first, t2 = edges[i - 1].second;\r\nint p1 = getParent(t1);\r\nint p2 = getParent(t2);\r\nif (p1 == p2) {\r\n    // if point, memo it and break.\r\n    point = i;\r\n    break;\r\n}\r\nif (p1 < p2) {\r\n    parent[p2] = p1;\r\n}\r\nelse {\r\n    parent[p1] = p2;\r\n}\r\n```","title":"분리 집합 구현 시 주의 점","date":"$D2023-10-11T00:00:00.000Z","description":"분리집합의 구현에 관해서는 union-find 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.","dateString":"Oct 11, 2023"}]}]}]]}],null]]},[null,["$","html",null,{"lang":"en","suppressHydrationWarning":false,"children":[["$","head",null,{"children":["$","script",null,{"type":"text/javascript","dangerouslySetInnerHTML":{"__html":"\n    let localTheme = localStorage.getItem(\"theme\");\n    if(!localTheme) {\n      localTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n      localStorage.setItem(\"theme\", localTheme);\n    }\n    \n    const html = document.querySelector(\"html\");\n    html.dataset.theme = localTheme;"}}]}],["$","body",null,{"className":"__className_e3dc15 layout_layout__dCqca","children":["$","div",null,{"id":"layout_layout__dCqca","children":[["$","div",null,{"className":"SideMenu_wrap__S7Kks","children":[["$","$L10",null,{"className":"SideMenu_logoLink__h5lXm","href":"/","children":["$","span",null,{"className":"SideMenu_logoCharacter___HzC9","children":"Chayhan."}]}],["$","$L11",null,{"className":"SideMenu_pfp__Hne0u","width":130,"height":130,"src":"https://avatars.githubusercontent.com/u/65532873?v=4","alt":"profile-picture-error"}],["$","div",null,{"className":"SideMenu_title__9PGW3","children":"Chayhan’s blog"}],["$","div",null,{"className":"SideMenu_desc__hXAjA","children":"이 녀석에게 친추 줘서 무료로 훈수 주기"}],["$","div",null,{"className":"SideMenu_links__tV5ui","children":[["$","div",null,{"children":["$","$L10",null,{"href":"https://github.com/chayhan","children":"Github"}]}],["$","div",null,{"children":["$","$L10",null,{"href":"https://discord.gg/w8xnMDgcxA","children":"Discord"}]}],["$","div",null,{"children":["$","$L10",null,{"href":"https://solved.ac/profile/blu3fishez","children":"Solved.ac"}]}]]}]]}],["$","div",null,{"id":"layout_contentWrap__twyu_","children":[["$","div",null,{"id":"layout_content__jhh_K","children":[["$","div",null,{"id":"layout_article__X_X3Z","children":[["$","div",null,{"className":"nav-container","children":["$","$L12",null,{}]}],["$","div",null,{"id":"$undefined","children":["$","$L13",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L14",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/b90cdb544708177e.css","precedence":"next","crossOrigin":""}]]}]}]]}],["$","div",null,{"className":"Toc_wrap__P1Agf","children":[["$","div",null,{"children":"최근 읽은 글"}],["$","hr",null,{}],["$","ul",null,{"children":["$","li",null,{"children":"현재 기능 개발 중"}]}]]}]]}],["$","footer",null,{"className":"Footer_footer__Gowxd undefined","children":["$","div",null,{"className":"Footer_footerWrap__EVpy3","children":[["$","p",null,{"className":"Footer_supportLog__zX5GZ","children":["Support me by following on",["$","a",null,{"href":"https://github.com/chayhan","children":[["$","$L11",null,{"className":"Footer_githubLogo__v_D4v","src":"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/github-icon.png","alt":"favicon","width":23,"height":23}],["$","span",null,{"style":{"textDecorationLine":"underline"},"children":"github"}]]}]]}],["$","p",null,{"className":"Footer_copyright__G_vwC","children":"© 2023 chayhan, Powered by github.io"}]]}]}]]}]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/1d5397ff1d0b753b.css","precedence":"next","crossOrigin":""}],["$","link","1",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/0cd104e7152108ad.css","precedence":"next","crossOrigin":""}]],"$L15"]]]]
15:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Main :: chayhan's Blog --"}],["$","meta","3",{"name":"description","content":"개발자 chayhan 의 블로그 입니다."}],["$","meta","4",{"property":"og:title","content":"chay의 깃허브 블로그"}],["$","meta","5",{"property":"og:description","content":"chayhan.github.io 블로그"}],["$","meta","6",{"property":"og:site_name","content":"chayhan's blog"}],["$","meta","7",{"property":"og:image","content":"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png"}],["$","meta","8",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","9",{"name":"twitter:title","content":"chay의 깃허브 블로그"}],["$","meta","10",{"name":"twitter:description","content":"chayhan.github.io 블로그"}],["$","meta","11",{"name":"twitter:image","content":"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png"}],["$","link","12",{"rel":"icon","href":"/markdown-blog/favicon.ico","type":"image/x-icon","sizes":"48x48"}]]
1:null
