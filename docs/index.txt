1:HL["/markdown-blog/_next/static/css/aa72cca261c59d32.css","style",{"crossOrigin":""}]
2:HL["/markdown-blog/_next/static/css/99ba6f541c247ce1.css","style",{"crossOrigin":""}]
0:["1rjHIA0enH95Rynekf_sX",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/aa72cca261c59d32.css","precedence":"next","crossOrigin":""}],["$","link","1",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/99ba6f541c247ce1.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:HL["/markdown-blog/_next/static/css/32a1eb6868504c55.css","style",{"crossOrigin":""}]
6:I[2368,["211","static/chunks/0709da7f-b10468a6184c0a34.js","806","static/chunks/806-60c66b7d354845cb.js","29","static/chunks/29-f5de225bd97809f0.js","901","static/chunks/901-82f86210965fcfb9.js","185","static/chunks/app/layout-d7e4b08b8cdad342.js"],""]
7:I[3810,[],""]
8:I[3844,[],""]
a:I[4029,["806","static/chunks/806-60c66b7d354845cb.js","402","static/chunks/402-795105111abddcdf.js","931","static/chunks/app/page-181810a109277ae5.js"],""]
11:I[3029,["211","static/chunks/0709da7f-b10468a6184c0a34.js","806","static/chunks/806-60c66b7d354845cb.js","29","static/chunks/29-f5de225bd97809f0.js","901","static/chunks/901-82f86210965fcfb9.js","185","static/chunks/app/layout-d7e4b08b8cdad342.js"],"Image"]
b:T7a5,
## 나의 접근

이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데
도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다...

스택의 특징을 아직 잘 몰라서 실수를 했는데, 스택이 사용될 수 있는 상황은 다음과 같습니다.

- 현재 문제 상황이 선형적이지만, 여태까지 내가 "탐색"했던 정보들을 바탕으로 판단해야할 때,

- 혹은 탐색했지만 정답을 찾지못한 정보들을 모아두었다가 나중에 일괄적으로 문제를 해결할 수 있을 때,

- 그 외 느낌상으로 모아두었다가 해결할 수 있을 것 같을 때

한번 쯤 생각해보면 좋을 것 같습니다. 스택..실제로 활용 문제를 실전풀이로 할 때 상당히 어려운 것 같습니다.

## 알고리즘

1. 현재 수를 보고 다음 수를 본다, 다음 수가 더 크다면, 기본적으로 현재 수의 NGE는 다음 수이다.

2. 만약 다음 수가 더 작다면, 현재수를 push 하고 다음 수를 본다.

3. 1의 과정 중, 다음 수가 현재수보다 크다면, 현재 수의 NGE는 다음 수 이다, 또한 스택이 비지 않았을 때, top이 현재 시점의 다음 수보다 작을 경우, 해당 수의 NGE도 현재 시점의 다음 수이다.

## 소스코드

```cpp
#include<iostream>
#include<stack>
#include<vector>
using namespace std;

int main() {
	cout.tie(0); cin.tie(0)->sync_with_stdio(0);
	int n; cin >> n;
	vector<int> arr(n);
	vector<int> ans(n, -1);
	stack<int> st;

	for (int i = 0; i < n; ++i) {
		cin >> arr[i];
	}
	
	for (int i = 0; i < n - 1; ++i) {
		if (arr[i + 1] > arr[i]) {
			ans[i] = arr[i + 1];
			while (!st.empty() && arr[st.top()] < arr[i + 1]) {
				ans[st.top()] = arr[i + 1];
				st.pop();
			}
		}
		else if (arr[i + 1] <= arr[i]) {
			st.push(i);
		}
	}
	for (int t : ans) {
		cout << t << ' ';
	}
}
```c:T516,
### 소스 코드

```cpp
#include<iostream>
using namespace std;

int n, k, l;
string input;

int u[10001][10001];
int dp[10001]; // 유사 펠린드롬의 여부 = 1 이상이면 해당, 또 1 이상인 값이 여러개 일 경우 가장 적은 값 입니다.

int getU(int s, int e) {
	if (s >= e) return 0;
	if (u[s][e]) return u[s][e];
	if (input[s] != input[e]) return 0;
	return u[s][e] = 1 + getU(s + 1, e - 1);
}

bool is_theta(int s, int e) {
	if (s == e) return false;

	int len = e - s + 1;
	int v_len = getU(s, e);

	if (k*len <= 2 * v_len * l) return true;
	return false;
}

int main() {
	cin >> n >> k >> l >> input;

	for (int i = 0; i < n; ++i) {
		dp[i] = -1;

		if (is_theta(0, i)) dp[i] = 1;

		for (int j = 1; j < i; ++j) {
			// 끝점이 i인 경우를 모두 검색하다보면 dp 값을 한번만 방문할 수 있을 것이다.
			// 1 ~ j / j + 1 ~ i 이렇게 두개로 나눔.
			// 더 작은 segment로 나뉠 수 있는 것 아닌가? -> 그 경우는 이미 dp[a][b] : b가 i보다 작은 경우에서 모두 구했음.
			if (is_theta(j, i) && dp[j - 1] > 0) {
				if (dp[i] > 1 + dp[j - 1] || dp[i] == -1) {
					
					dp[i] = dp[j - 1] + 1;
				}
			}
		}
	}
	
	cout << ((dp[n - 1] == -1) ? 0 : dp[n - 1]);
}
```d:T17f4,
## 접근


처음 접근은 이랬습니다. 사실 제일 처음에 어려웠던 부분은 d-정상이 무엇인지 이해를 하는 것이였습니다.

d만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데,
잘못된 방법이였습니다.

땅에서부터 d 만큼의 높이차가 존재하는 지역이 정상이라고 생각할 수 없는 이유는, 해당하는 높은 지역 사이에 그 지역보다 더 높은 지역이 있을지도 모르기 때문입니다.

예를들어, 해당 지점이 땅이 아닌 지점이면서 (h-d)보다 더 낮은 지점이 방문 가능한 봉우리 h가 있다고 하면 어떻게 될까요?

그림으로 설명해보겠습니다.

```
- 제일 높은 위치 (0)
			            ---           ==> 여긴 d 정상임 (1)
		                | -> d보다 작음
            ------  ===========> 여긴 d 정상이 아님. (2)
            | -> d보다 큼.
---- 땅 -
```

```
1
2 4 2
5 0 3 4
```

가장 높은 지점에서만 bfs하면  (1)이 d-정상임을 판별할 수 없고,

땅에서부터 bfs하면 (2)가 d-정상이 아님을 판별할 수 없습니다.

따라서 저희는 모든 점을 찾아볼 수 밖에 없습니다.

다만, 그중에서 가장 높은 "정상"부터 BFS해야합니다. d-정상의 정의에 따르면 높이가 어떻든, 가장 높은 점은 자신보다 더 높은 점이 존재하지 않기 때문에 주어진 맵에서 가장 높은 높이를 부여받은 지점은 무조건 d-정상에 해당됩니다.

일단 가장 높은 지점에서부터 높이차가 d보다 작은 지점들을 bfs 하면서 visit 을 했다는 표식을 남깁시다.

이 표식이 그 다음으로 가장 높은 지점에서  높이차가 d보다 작은 지점들을 bfs를 하다가 사전에 방문했던 지점들을 만난다면, 그것은 d-정상의 정의에 위배됩니다. 따라서 해당 bfs시작점을 비롯한 bfs 중 만났던 해당 bfs 시점 중 가장 높은 지점들 전부 d-정상에 위배됩니다.

현재 bfs 중 방문햇던 지점과, 이전에 이미 방문했었던 지점을 구별하기 위해 `visit` 값은 `bool`이 아닌 `int` 값을 사용했습니다.

## 구현

1. 가장 높은 지역을 BFS 한다.

2. 닿지 않는 지역 중 그다음으로 가장 높은 지역을 BFS 한다. // 각 세그 먼트 중 자신보다 높은 지역이 닿이는 세그먼트는 d 정상이 아니다.

3. `queue`를 sorting 할거면.. `priority queue`를 사용.

PQ를 사용한 뒤, 일단 visit 배열을 정상값으로 칠합니다. 이게 무슨 소리냐면, 3 이 정상이라 하면, 최소 (3 - d)인 지점을 모두 bfs 해가며 해당 부분의 visit 값은 가장 높은 정상의 값으로 정한다는 뜻입니다.

만약 해당 bfs segment 도중에 자신보다 높은 지점을 나타내는 , 해당 bfs 서브프로세스에서 얻는 d-정상의 개수는 무조건 0으로 합니다. 단, 추후 bfs 할 프로세스에서 가장 높은 h는 현재의 h보다 작기 때문에 bfs 세그먼트를 계속해야합니다.

도중에 자신과 같은 높이의 지점을 만났다면 bfs segment 에서 더할 d-정상의 개수를 1 늘립니다.

도중에 라벨된 지점을 만났다면 해당 segment에서 얻는 d-정상의 개수는 0입니다. 왜냐하면 지점이 높은순으로 라벨링을 했기 때문입니다.

## 내가 계속 틀렸던 이유

### board를 클리어하지 않아서 계속 틀렸었다.

이때 `vector`를 써야하는 이유를 알았습니다.

vector 가 갖는 또 다른 이점은 로컬 변수로 선언함으로써 반복문 내에서도 부담없이 memset할 필요가 없었고, 무엇보다 스택 영역을 차지하지 않음으로써 스택오버플로우도 면할 수 있었습니다. 여러모로 상당히 고마운 존재입니다.

### board[n+2][m+2] 와 같은 형식으로 구현하고자 하는 경우

이럴땐 board[][]의 경계선을 확실히 해주도록합시다. 문제에선 0이 가장 낮은 땅이므로 경계선과 땅을 구별할 수 없습니다.

따라서 입력된 board[][] 값을 모두 1씩 올려줌으로써 해결했습니다.


## 소스코드

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
typedef pair<int, int> pii;

int board[502][502];
int visit[502][502] = { 0, };
int dir[4][2] = {
	{0, 1},
	{0, -1},
	{1, 0},
	{-1, 0}
};

int n, m, d, total;
priority_queue<pair<int, pii>> pq;
queue<pii> bfs_q;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	while (t--) {
		total = 0;
		cin >> n >> m >> d;
		for (int i = 0; i <= n + 1; ++i) {
			memset(visit[i], 0, sizeof(visit[i]));
			memset(board[i], 0, sizeof(board[i]));
		}

		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= m; ++j) {
				cin >> board[i][j];
				board[i][j]++;
				if (board[i][j]) {
					pq.push({ board[i][j], {i, j} });
				}
			}
		}

		int visit_seg = 0;

		while (!pq.empty()) {
			int d_summit = 1;
			visit_seg++;
			int h = pq.top().first;
			int st_x = pq.top().second.second;
			int st_y = pq.top().second.first;
			pq.pop();

			if (visit[st_y][st_x]) continue;
			visit[st_y][st_x] = visit_seg;

			bfs_q.push({ st_y, st_x });

			while (!bfs_q.empty()) {
				int y = bfs_q.front().first;
				int x = bfs_q.front().second;
				bfs_q.pop();

				for (int i = 0; i < 4; ++i) {
					int dy = y + dir[i][0];
					int dx = x + dir[i][1];

					if (!board[dy][dx]) continue;

					if (visit[dy][dx] && visit[dy][dx] < visit_seg) {
						d_summit = 0;
						continue;
					}

					if (visit[dy][dx] == visit_seg) continue;

					if (board[dy][dx] == h) {
						if (d_summit) d_summit++;
					}

					if (!visit[dy][dx] && board[dy][dx] > h - d) {
						visit[dy][dx] = visit_seg;
						bfs_q.push({ dy, dx });
					}
				}

			}

			total += d_summit;
		}

		cout << total << '\n';
	}
}
```


e:T1328,
## `next_permutation()` 이란?

알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다. 물론 
이런 경우는 사실 대부분 재귀함수를 사용하다보면 해결이 되는 경우가 많습니다.

하지만 재귀를 통한 경우의 수 추출의 경우, 모든 경우의 수의 처리를 위해서는 해당 함수 호출스택 내에서 외부 변수에 모두 모아놓거나, 각각의 경우의 수가 완성된 경우의 함수 스택 상태 위에서 작업을 실행해야 모든 경우의 수에 대한 대응이 가능합니다.

간단한 처리의 경우는 상관 없지만, `스택 오버플로우` 와 같은 오류를 내고 싶지 않은 상황이거나 재귀 함수를 사용 하는 것에 대해 약간 민감한 상황이라면, `next_permutation` 을 사용하는 것이 좋다고 생각합니다.

`next_permutation()` 함수는 `algorithm` 내 헤더에 있으며, 보통은 함수의 인자로 `iterator` 의 처음 부분과 끝 부분을 넣습니다.

이때 `iterator` 의 개념에 대해 간단히 이야기하자면, 그냥 배열의 요소를 가르킨다고 보시면 됩니다. `C++`을 알고리즘 문제풀이로 사용하는 입장에서는 일반적인 배열과 `vector` 의 처음과 끝 포인터가 들어간다고 생각하면 됩니다.

해당 함수가 호출되면, 함수의 인자로 들어간 `배열 객체의 다음 순열의 순서`로 변경해줍니다. 이때 정의된 배열의 순열의 순서는 오름차순이 기준입니다.

예를 들어, `0 0 1` 의 순열을 오름차순으로 나열하였을 때, 해당 배열의 다음 순열은 `0 1 0` 일 겁니다. 그 다음은 `1 0 0` 일 것입니다.

따라서 보통 일반적으로 `next_permutation()`을 호출하기 전에 오름차순에 따라 **정렬을 해두고 사용 해야 모든 순열의 경우의 수를 확인할 수 있습니다.**

## 조합을 뽑는 방법

`next_permutation` 에서는 값이 같은 배열의 요소를 동일한 원소로 취급합니다. 이 점을 이용하여 조합을 만들 수도 있습니다.

이게 무슨 뜻이냐면, `0(1번째 원소) 0(2번째 원소) 1` 이라는 내용의 배열이 있다면, `0` 두개가 동일원소로 취급되지 않는 중복 순열 이라면 다음 순열은 `0(2번째 원소) 0(1번째 원소) 1` 이 다음 순열이여야합니다. 하지만 `next_permuation` 에서는 중복을 허용하지 않는 순열을 반환하기 때문에 중복 원소에 대한 순열은 스킵이 됩니다.

이를 통해 조합을 구성하는 방법은 간단합니다. 뽑는가, 뽑지 않는가 여부만 판단하는 것이 조합이므로, 뽑는 수만큼 `1`, 뽑지 않는 수만큼 `0`으로 구성된 0-1 배열을 구성하여 `next_permutation` 함수를 호출 하면, 모든 조합의 경우의 수를 알 수 있습니다.

## 응용

해당 문제는 응용입니다. 문제를 풀고 밑부분을 참고하세요.

- [[ 백준 18809 ] Gaaaaarden : C++ 풀이](https://johannblue.github.io/markdown-blog/13)


### 활용 설명

위에서 조합을 응용하는 방법은 그렇습니다.

조합을 두번 뽑지 않고, 중복순열이 아닌 점을 활용하는 겁니다.

땅이 5개, 그중에 빨간 배양액 2곳과 초록 배양액 2곳을 사용한다고 하는 예제 입력이 있다고 합시다. 그런 경우에 `0 1 1 2 2` 와 같은 배열의 순열을 순회하면 배양액을 뿌리는 모든 경우의 수를 저희는 확인할 수가 있을 것입니다.

위와 같은 방식으로 문제를 활용할 수도 있을 것입니다.

## 코드 짜는 법

이제부터는 실제 코드 사용법에 대해 알아보겠습니다.

익숙치 않는 문법을 사용할 건데요. `do - while` 문을 사용할 것입니다. 그것에는 이유가 있습니다. `sort` 를  통해 순열을 확인할 배열을 정렬했다면, 일단 맨 첫번째 순열은 이미 정렬된 해당 배열이기 때문에 해당 구문을 이용해 일단 확인해도 모든 경우의 수를 확인할 수 있기 때문입니다.

`while`문의 조건 문에서 next_permutation()을 호출하면 현재 해당 배열이 마지막 순열( = 현재 배열이 내림차순인지)인지 아닌지에 따라 `return` 값이 달라집니다.

마지막 순열이라면 false를 출력하기 때문에 순열을 순회하기도 쉽습니다.

1. 배열 구성하기
2. `sort` 하기
3. `do - while` 구문으로  순회하기

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main() {
    int arr[5];
    for (int i = 0; i < 5; ++i) {
        arr[i] = i + 1;
    }
    sort(arr, arr + 5);
    do {

        for (auto i : arr) {
            cout << i << ' ';
        }
        cout << '\n';
    } while (next_permutation(arr, arr + 5));
}
```f:T8b0,### 소스코드

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

int n, m;
int r, g;
int board[52][52]; // 맵

vector<pair<int, int>> able_list; // 배양액 뿌릴 수 있는 땅 정보

int dir[4][2] = {
	{0, 1},
	{1, 0},
	{0, -1},
	{-1, 0}
};

int flowers; // 꽃의 개수

void bfs(vector<pair<int, int>>& gv, vector<pair<int, int>>& rv) {
	int visit[52][52] = { 0, }; // 빨간색 -t 값. 초록색 t 값으로 시간을 표현. 1초부터 시작. 0이면 닿지않은 경우임.
	int f = 0; // 현재 꽃
	queue<pair<int, pair<int, int>>> q; // bfs q

	for (auto t : gv) {
		visit[t.first][t.second] = -1;
		q.push({ -1, t });
	}

	for (auto t : rv) {
		visit[t.first][t.second] = 1;
		q.push({ 1, t });
	}

	while (!q.empty()) {
		int time = q.front().first;
		pair<int, int> node = q.front().second; q.pop();

		int y = node.first;
		int x = node.second;

		if (visit[y][x] == 9999) continue; // 꽃은 퍼지지 않음.

		visit[y][x] = time;

		if (time > 0) time++;
		else time--;

		for (int i = 0; i < 4; ++i) {
			int dy = y + dir[i][0];
			int dx = x + dir[i][1];

			if (visit[dy][dx] + time == 0) {
				visit[dy][dx] = 9999;
				f++;
				continue;
			}

			if (board[dy][dx] && visit[dy][dx] == 0) {
				q.push({ time, {dy, dx} });
				visit[dy][dx] = time;
			}
		}
	}
	flowers = flowers < f ? f : flowers;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m >> r >> g;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			cin >> board[i][j];
			if (board[i][j] == 2) {
				able_list.push_back({ i, j });
			}
		}
	}


	vector<int> p;
	for (int i = 0; i < able_list.size() - r - g; ++i) p.push_back(0);
	for (int i = 0; i < r; ++i) p.push_back(1);
	for (int i = 0; i < g; ++i) p.push_back(2);

	do {

		vector<pair<int, int>> r_list;
		vector<pair<int, int>> g_list;

		for (int i = 0; i < p.size(); ++i) {
			if (p[i] == 1) r_list.push_back(able_list[i]);
			if (p[i] == 2) g_list.push_back(able_list[i]);
		}

		bfs(g_list, r_list);

	} while (next_permutation(p.begin(), p.end()));

	cout << flowers;
}
```10:T8bd,## 이미지 가져오기

이미지를 가져오는 건 리액트처럼 그냥 해당  프로젝트 내에서도 가져올 수 있는데 문제는 asset들은 모두 `public` 폴더 를 root로 하기 때문에 해당 폴더 내에만 배치를 해야한다.

본 문서들도 모두 public 에 배치된 이유가 그렇기 때문이다.

## 동적 라우팅

동적 라우팅은 app router 에서는 이전 레거시 버전처럼 폴더 이름의 양 끝을 대괄호로 감싼 다음, 그 안의 `page.ts` 에서 `params` 라는 속성을 받게 만든다면 알아서 서버 컴포넌트에서 params 에 폴더 이름에 대응하는 값을 params 에 해당 폴더 이름으로 속성으로 넣어준다.

## 페이지의 타이틀 변경

타이틀 부분은 중요하다.

같은 솔루션 페이지를 여러군데를 띄워놓앗을 때 어떤 탭의 페이지가 어떤 내용을 함축하고있는지 나타내주어야하는데 가장 간단한 방법이 타이틀을 바꾸는 방법이다. 

- 해결방법 : `<Head>` 기능을 사용하면 된다.

일단 아래처럼 가져온다.

```js
import Head from 'next/head'
```

그런데 알고보니 이게 app router 에서는 이렇게 사용하지 않는다고 한다.

![Alt text](image.png)

해결방법은 아래와 같이 Metadata 값을 재정의 해주는 것만으로 새롭게 바뀌는 가보다. 작동방식이 상당히 특이하다. 아마 해당 Functional Component의 default export 값만 보는게 아닌 것 같다.

![Alt text](image-1.png)

## Typescript on React : 자식 설정

`This JSX tag's 'children' prop expects a single child of type 'ReactElement<any, string | JSXElementConstructor<any>>', but multiple children were provided.`

위와 관련된 에러 해결이다.

아래와 같이 설정하자.

```js
children: JSX.Element|JSX.Element[];
```

### Typescript 에서 React Children 설정 방법

총 3가지가 있음.

- React.ReactNode
- JSX.Element 
- React.ReactElement


이렇게 3가지가 있는데, React.ReactNode를 사용하면 `string`, `number`를 비롯한 JSX 노드들을 중복/단일 상관없이 받기 때문에, `React.ReactNode` 를 사용하면 됩니다.3:[null,["$","html",null,{"lang":"en","suppressHydrationWarning":false,"children":["$","body",null,{"className":"__className_36bac3","children":[["$","div",null,{"id":"body-wrapper","children":[["$","div",null,{"className":"nav-container","children":["$","$L6",null,{}]}],["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$L9",["$","div",null,{"className":"page_mainWrap__G2_gf","children":[["$","div",null,{"className":"page_title__3jonF","children":"Posts"}],["$","div",null,{"className":"page_description__86bsR","children":"다양한 주제로 글을 씁니다."}],["$","div",null,{"className":"page_hr__LC6V_"}],["$","$La",null,{"articleList":[{"slug":"2023-10-25-boj17298","content":"$b","title":"[ 백준 17298 ] 오큰수 : C++ 풀이","date":"$D2023-10-25T00:00:00.000Z","description":"이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데 도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다.","dateString":"Oct 25, 2023"},{"slug":"2023-10-24-boj13330","content":"$c","title":"[ 백준 13330 ] 유사 팰린드롬 : C++ 풀이","date":"$D2023-10-24T00:00:00.000Z","description":"소스코드만 있습니다.","dateString":"Oct 24, 2023"},{"slug":"2023-10-23-boj3697","content":"$d","title":"[ 백준 3697 ] 정상 : C++ 풀이","date":"$D2023-10-23T00:00:00.000Z","description":"d만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데, 잘못된 방법이였습니다.","dateString":"Oct 23, 2023"},{"slug":"2023-10-21-next-permutation","content":"$e","title":"[ C++ ] 조합, 순열 을 next_permutation() 으로 순회하기","date":"$D2023-10-21T00:00:00.000Z","description":"알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다.","dateString":"Oct 21, 2023"},{"slug":"2023-10-20-boj18809","content":"$f","title":"[ 백준 18809 ] Gaaaaarden : C++ 풀이","date":"$D2023-10-20T00:00:00.000Z","description":"소스코드만 있습니다.","dateString":"Oct 20, 2023"},{"slug":"2023-10-14-lis","content":"## 풀이\r\n\r\n풀이는 제 이전 블로그에서 확인 가능합니다.\r\n\r\n## [소스코드 : LIS 3](https://boj.kr/12783)\r\n\r\n```cpp\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint n, len;\r\n\r\nint arr[1000000];\r\nint lis[1000000];\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tcin >> n;\r\n\r\n\tfor (int i = 0; i < n; ++i) cin >> arr[i];\r\n\r\n\tlen = 1;\r\n\tlis[0] = arr[0];\r\n\t\r\n\tfor (int i = 1; i < n; ++i) {\r\n\t\tint l = 0;\r\n\t\tint h = len;\r\n\t\tint upper_bound = h;\r\n\r\n\t\twhile (l <= h) {\r\n\t\t\tint mid = (l + h) / 2;\r\n\t\t\tif (lis[mid] < arr[i]) {\r\n\t\t\t\tl = mid + 1;\r\n\t\t\t}\r\n\t\t\telse if (lis[mid] >= arr[i]) {\r\n\t\t\t\tupper_bound = mid;\r\n\t\t\t\th = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlis[upper_bound] = arr[i];\r\n\t\tif (len == upper_bound) {\r\n\t\t\tlen += 1;\r\n\t\t}\r\n\r\n\t}\r\n\tcout << len;\r\n}\r\n```\r\n\r\n## 주의점\r\n\r\n### `upper bound`를 확실히 구할 것!\r\n\r\n해당 값을 제대로 구했는지 확인할 요소\r\n\r\n1. `while(lo < hi)` 가 아니라 `while(lo <= hi)` 인지\r\n\r\n```\r\n7\r\n4 5 6 1 2 3 4\r\n\r\n정답 : 4\r\n```","title":"LIS 알고리즘 개념","date":"$D2023-10-14T00:00:00.000Z","description":"풀이는 제 이전 블로그에서 확인 가능합니다.","dateString":"Oct 14, 2023"},{"slug":"2023-10-12-nojekyll","content":"# `.nojekyll` 설정하기\r\n\r\n이거 때문에 하루를 날려먹었다.\r\n\r\n`gh-pages` 를 통해 호스팅하는 모든 페이지들은 `jekyll` 블로그 설정에 따라 호스팅 되는 경우가 많아, 깃허브에서\r\n자체적으로 `_next` 와 같은 디렉토리를 차단시켜버리는 경향이 있습니다.\r\n\r\n이를 막기위해서 gh-pages에 deploy할 branch의 루트폴더에 `.nojekyll` 이라는 이름의 파일을 두어 깃허브가\r\n해당 정적페이지는 제킬이 아님을 알려주어야 인식이 정상적으로 된다.","title":"깃허브 페이지에서 _next/ 폴더에 접근할 수 없는 경우","date":"$D2023-10-12T00:00:00.000Z","description":".nojekyll 설정하기","dateString":"Oct 12, 2023"},{"slug":"2023-10-12-boj11401","content":"## 설명\r\n\r\n일단 이 문제를 풀기 위해선 `페르마의 소정리`와 `모듈러 역원`을 구하는 연산을 할줄 알아야한다.\r\n\r\n\r\n\r\n### 소스코드\r\n\r\n```cpp\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint n, r;\r\nint fact[4000001];\r\nconst long long MOD = 1000000007;\r\n\r\nlong long getFact(long long n) {\r\n\tif (n == 0) return 1;\r\n\tif (fact[n]) return fact[n];\r\n\treturn fact[n] = n * (long long)getFact(n - 1) % MOD;\r\n}\r\n\r\nlong long power(long long base, int exp) {\r\n\tif (!exp) return 1;\r\n\tlong long i = 1;\r\n\twhile (exp) {\r\n\t\tif (exp % 2) {\r\n\t\t\ti *= base;\r\n\t\t\ti %= MOD;\r\n\t\t\texp--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tbase *= base;\r\n\t\tbase %= MOD;\r\n\t\texp /= 2;\r\n\t}\r\n\treturn i;\r\n}\r\n\r\nint main() {\r\n\tcin >> n >> r;\r\n\tlong long numer = getFact(n);\r\n\tlong long deno = getFact(r) * getFact(n - r) % MOD;\r\n\tdeno = power(deno, MOD - 2);\r\n\tnumer = numer * deno % MOD;\r\n\tcout << numer;\r\n}\r\n```","title":"[ 백준 11401 ] 이항 계수 3 : C++ 풀이","date":"$D2023-10-12T00:00:00.000Z","description":"일단 이 문제를 풀기 위해선 페르마의 소정리와 모듈러 역원을 구하는 연산을 할줄 알아야한다.","dateString":"Oct 12, 2023"},{"slug":"2023-10-11-next-js-blog","content":"$10","title":"[Next.js] 블로그 만들 때 생긴 에러 해결방안들 임시 메모","date":"$D2023-10-11T00:00:00.000Z","description":"이미지 가져오기, 동적 라우팅, 페이지 타이틀 변경 등","dateString":"Oct 11, 2023"},{"slug":"2023-10-11-hello-world","content":"\r\n# 제목1\r\n\r\n## 제목 2\r\n\r\n### 제목 3\r\n\r\n#### 제목 4\r\n\r\n> 인용 태그\r\n\r\n안녕하세요.\r\n\r\n`Code`\r\n\r\n```cpp\r\nprintf(\"code\");\r\n```\r\n\r\n[link](\"/\")\r\n\r\nanything else?\r\n\r\n블로그의 탄생을 축하하며.","title":"Hello, World!","date":"$D2023-10-11T00:00:00.000Z","description":"블로그의 탄생을 축하하며.","dateString":"Oct 11, 2023"},{"slug":"2023-10-11-disjoint-set","content":"분리집합의 구현에 관해서는 `union-find` 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.\r\n\r\n문제를 풀다가 이번에도 같은 방식으로 틀려서 기록하게 되었다.\r\n\r\n```cpp\r\nparent[t1] = p2;\r\n```\r\n\r\n위와 같이 바꾸게 되면, t1의 부모까지 부모값이 p2로 갱신되지 않고 짤리므로 위와 같이 구현하면 안된다.\r\n\r\n따라서 아래와 같이 그냥 부모노드의 부모값을 바꿔주어야한다.\r\n\r\n```cpp\r\nint t1 = edges[i - 1].first, t2 = edges[i - 1].second;\r\nint p1 = getParent(t1);\r\nint p2 = getParent(t2);\r\nif (p1 == p2) {\r\n    // if point, memo it and break.\r\n    point = i;\r\n    break;\r\n}\r\nif (p1 < p2) {\r\n    parent[p2] = p1;\r\n}\r\nelse {\r\n    parent[p1] = p2;\r\n}\r\n```","title":"분리 집합 구현 시 주의 점","date":"$D2023-10-11T00:00:00.000Z","description":"분리집합의 구현에 관해서는 union-find 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.","dateString":"Oct 11, 2023"}]}]]}],null],"segment":"__PAGE__"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/markdown-blog/_next/static/css/32a1eb6868504c55.css","precedence":"next","crossOrigin":""}]]}]]}],["$","footer",null,{"className":"Footer_footer__Gowxd","children":["$","div",null,{"className":"Footer_footerWrap__EVpy3","children":[["$","p",null,{"className":"Footer_supportLog__zX5GZ","children":["Support me by following on",["$","a",null,{"href":"https://github.com/johannblue","children":[["$","$L11",null,{"className":"Footer_githubLogo__v_D4v","src":"https://raw.githubusercontent.com/johannblue/markdown-blog/main/public/github-icon.png","alt":"favicon","width":23,"height":23}],["$","span",null,{"style":{"textDecorationLine":"underline"},"children":"github"}]]}]]}],["$","p",null,{"className":"Footer_copyright__G_vwC","children":"© 2023 johannblue, Powered by github.io"}]]}]}]]}]}],null]
4:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Johann blog"}],["$","meta","3",{"name":"description","content":"Generated by create next app"}],["$","meta","4",{"property":"og:title","content":"Johann Kim's blog"}],["$","meta","5",{"property":"og:description","content":"Visit our site for more detail information."}],["$","meta","6",{"property":"og:site_name","content":"Johann Kim's blog"}],["$","meta","7",{"property":"og:image","content":"https://raw.githubusercontent.com/johannblue/markdown-blog/main/public/favicon-128.png"}],["$","meta","8",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","9",{"name":"twitter:title","content":"Johann Kim's blog"}],["$","meta","10",{"name":"twitter:description","content":"Visit our site for more detail information."}],["$","meta","11",{"name":"twitter:image","content":"https://raw.githubusercontent.com/johannblue/markdown-blog/main/public/favicon-128.png"}],["$","link","12",{"rel":"icon","href":"/markdown-blog/favicon.ico","type":"image/x-icon","sizes":"48x48"}]]
9:null
