<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/markdown-blog/_next/static/css/1d5397ff1d0b753b.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/markdown-blog/_next/static/css/6d5e3c23a0d301f9.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/markdown-blog/_next/static/css/6faf9db9f4b4400b.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/markdown-blog/_next/static/chunks/webpack-2f30501573afcb8b.js" crossorigin=""/><script src="/markdown-blog/_next/static/chunks/d16e89e2-16dd9198aa4e276b.js" async="" crossorigin=""></script><script src="/markdown-blog/_next/static/chunks/543-d8e95678ffa4228d.js" async="" crossorigin=""></script><script src="/markdown-blog/_next/static/chunks/main-app-27063a20fdaee825.js" async="" crossorigin=""></script><script src="/markdown-blog/_next/static/chunks/93-3c33722948fb8147.js" async=""></script><script src="/markdown-blog/_next/static/chunks/app/page-238176a5f1c3a848.js" async=""></script><script src="/markdown-blog/_next/static/chunks/729-fcd05f6bcbb192cf.js" async=""></script><script src="/markdown-blog/_next/static/chunks/app/layout-48d80b2056231da9.js" async=""></script><title>Main :: chayhan&#x27;s Blog --</title><meta name="description" content="개발자 chayhan 의 블로그 입니다."/><meta property="og:title" content="chay의 깃허브 블로그"/><meta property="og:description" content="chayhan.github.io 블로그"/><meta property="og:site_name" content="chayhan&#x27;s blog"/><meta property="og:image" content="https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="chay의 깃허브 블로그"/><meta name="twitter:description" content="chayhan.github.io 블로그"/><meta name="twitter:image" content="https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png"/><link rel="icon" href="/markdown-blog/favicon.ico" type="image/x-icon" sizes="48x48"/><script type="text/javascript">
    let localTheme = localStorage.getItem("theme");
    if(!localTheme) {
      localTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      localStorage.setItem("theme", localTheme);
    }
    
    const html = document.querySelector("html");
    html.dataset.theme = localTheme;</script><script src="/markdown-blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="__className_e3dc15 layout_layout__dCqca"><div id="layout_layout__dCqca"><div class="SideMenu_wrap__S7Kks"><a class="SideMenu_logoLink__h5lXm" href="/markdown-blog"><span class="SideMenu_logoCharacter___HzC9">Chayhan.</span></a><img alt="profile-picture-error" loading="lazy" width="130" height="130" decoding="async" data-nimg="1" class="SideMenu_pfp__Hne0u" style="color:transparent" src="https://avatars.githubusercontent.com/u/65532873?v=4"/><div class="SideMenu_title__9PGW3">Chayhan’s blog</div><div class="SideMenu_desc__hXAjA">이 녀석에게 친추 줘서 무료로 훈수 주기</div><div class="SideMenu_links__tV5ui"><div><a href="https://github.com/chayhan">Github</a></div><div><a href="https://discord.gg/w8xnMDgcxA">Discord</a></div><div><a href="https://solved.ac/profile/blu3fishez">Solved.ac</a></div></div></div><div id="layout_contentWrap__twyu_"><div id="layout_content__jhh_K"><div id="layout_article__X_X3Z"><div class="nav-container"><div class="Navbar_nav__1C48S"><a class="Navbar_home__kWENX" href="/markdown-blog">Chayhan.</a><div class="Navbar_themeChanger__I5pmp Navbar_dark__rp3V9"> <style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="DarkModeIcon"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"></path></svg> </div></div></div><div><div class="page_mainWrap__G2_gf"><div class="page_title__3jonF">Posts</div><div class="page_description__86bsR">다양한 주제로 글을 씁니다.</div><div class="page_hr__LC6V_"></div><!--$!--><template data-dgst="NEXT_DYNAMIC_NO_SSR_CODE"></template>loading...<!--/$--></div></div></div><div class="Toc_wrap__P1Agf"><div>최근 읽은 글</div><hr/><ul><li>현재 기능 개발 중</li></ul></div></div><footer class="Footer_footer__Gowxd undefined"><div class="Footer_footerWrap__EVpy3"><p class="Footer_supportLog__zX5GZ">Support me by following on<a href="https://github.com/chayhan"><img alt="favicon" loading="lazy" width="23" height="23" decoding="async" data-nimg="1" class="Footer_githubLogo__v_D4v" style="color:transparent" src="https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/github-icon.png"/><span style="text-decoration-line:underline">github</span></a></p><p class="Footer_copyright__G_vwC">© 2023 chayhan, Powered by github.io</p></div></footer></div></div><script src="/markdown-blog/_next/static/chunks/webpack-2f30501573afcb8b.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/markdown-blog/_next/static/css/1d5397ff1d0b753b.css\",\"style\",{\"crossOrigin\":\"\"}]\n2:HL[\"/markdown-blog/_next/static/css/6d5e3c23a0d301f9.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/markdown-blog/_next/static/css/6faf9db9f4b4400b.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[8546,[],\"\"]\n7:\"$Sreact.suspense\"\n8:I[2703,[\"93\",\"static/chunks/93-3c33722948fb8147.js\",\"931\",\"static/chunks/app/page-238176a5f1c3a848.js\"],\"\"]\n16:I[4632,[\"93\",\"static/chunks/93-3c33722948fb8147.js\",\"729\",\"static/chunks/729-fcd05f6bcbb192cf.js\",\"185\",\"static/chunks/app/layout-48d80b2056231da9.js\"],\"\"]\n17:I[3729,[\"93\",\"static/chunks/93-3c33722948fb8147.js\",\"729\",\"static/chunks/729-fcd05f6bcbb192cf.js\",\"185\",\"static/chunks/app/layout-48d80b2056231da9.js\"],\"Image\"]\n18:I[7723,[\"93\",\"static/chunks/93-3c337229"])</script><script>self.__next_f.push([1,"48fb8147.js\",\"729\",\"static/chunks/729-fcd05f6bcbb192cf.js\",\"185\",\"static/chunks/app/layout-48d80b2056231da9.js\"],\"\"]\n19:I[1949,[],\"\"]\n1a:I[881,[],\"\"]\n1c:I[3076,[],\"\"]\n9:T1ff5,"])</script><script>self.__next_f.push([1,"\n## 문제 접근\n\n원형 타일채우기 DP 라고 생각하면 쉽다. 발상이 어려워서 플레티넘3 이 아닌가 조심스레 추측한다.\n\n## 해결방법\n\n1. 타일 채우기 문제와 같이 생각을 해보자.\n2. 타일을 채우거나 그렇지 않거나만을 따져서 DP 테이블을 잘 짰다면, 경계선에 대한 부분은 경우의 수로 아예 나누어 선형 DP 로 바꾸어 풀어보도록 하자.\n\n## 타일을 나누는 법?\n\n내가 이부분을 생각못해서, 다른 블로그를 참고했다.\n\n타일을 나누는 방법에는 총 3가지 경우의 수가 있을 것이다.\n\n- 현재 열을 기준으로 윗쪽만 채웠을 경우 (1행만)  - a\n- 현재 열을 기준으로 아랫쪽만 채웠을 경우 (2행만) - b\n- 현재 열을 기준으로 윗쪽 아랫쪽 둘다 채웠을 경우 (둘다) - c\n\n이런식으로 열을 1부터 N열 까지 채워나가다보면 선형적으로 풀 수가 있다.\n\na 경우의 점화식은 이렇게 될 것이다. 이때 `a_n` 은 n번째 행의 a 값이라는 뜻이다.\n\n```\na_n = c_n-1 + 1  // 그냥 n행의 윗부분 한칸만 점령한 경우\nif (n, 0) + (n-1, 0) \u003c= w // 현재 열의 윗쪽 + 해당 칸의 왼쪽 칸을 같이 점령할 수 있는 경우\n\t\ta_n = min(a_n, b_n-1 + 1) // if 문의 점령을 하게 딱 맞추면 남은 칸은 b_n-1 이 된다.\n```\n\n위의 경우를 그림으로 표현해보면 아래와 같다.\n\n![Untitled](Untitled.png)\n\na는 N행에 위에만 칠해져야한다. 기본적인 경우는 이렇게 될 것이다. 한칸만 칠하면 되니까 근데 이제 (n-1, 0) 과 (n, 0) 을 한번에 같이 칠할 수(나누어 점령) 있다면 이렇게 될 것이다.\n\n![Untitled](Untitled_1.png)\n\nb 경우도 점화식은 a와 크게 다르지 않다. 위의 경우와 뒤집어 생각할 수 있을 것이다.\n\n```\nb_n = c_n-1 + 1 // 이 경우도 그냥 n행의 밑부분을 점령한 경우\nif (n, 1) + (n-1, 1) \u003c= w\n\t\tb_n = min(b_n, a_n-1 + 1)\n```\n\nc의 경우는 쫌 다른데, 일단은 `a_n` 과 `b_n` 을 먼저 구하고 나중에 구해야한다. 왜냐하면 `c_n` 이 `a_n + 1` (그냥 나머지칸을 칠하는 경우) 가 최소 값이 될 수도 있기 때문이다.\n\n또는 그냥 한번에 N행의 두칸을 한번에 점령할수도 있다.\n\n또는 (N, 0) 과 (N-1, 0) / (N, 1) 과 (N-1, 1) 을 각각 한 부대가 점령할 수도 있을 것이다.\n\n```\n// 본 코드는 의사 코드다.\nc_n = min(c_n-1 + 2, a_n + 1, b_n + 1)\nif (n, 1) + (n, 0) \u003c= w\n\t\tc_n = min(c_n-1 + 1, c_n)\nif (n, 1) + (n, 0) \u003c= w and (n-1, 1) + (n-1, 0) \u003c= w\n\t\tc_n = min(c_n, c_n-2 + 2)\n```\n\n![Untitled](Untitled_2.png)\n\n![Untitled](Untitled_3.png)\n\n![Untitled](Untitled_4.png)\n\n![Untitled](Untitled_5.png)\n\n### 원형 구조는 어떻게 해결하나요?\n\n타일을 나누는 방법을 올바르게 생각했다면 원형 구조도 자연스레 해결이 된다.\n\n끝부분과 처음부분을 걸쳐서 생각해보는 것이다.\n\n어쨌던 입력으로 받은 배열은 선형적이니 선형적으로 생각할 때, 처음과 끝부분이 있겠다.\n\n이 처음과 끝 부분에 걸쳐서 나누어 점령을 할 수 있는지 경우의 수를 나누는 것이다.\n\n그렇게한다면 총 4개의 경우의 수가 생긴다.\n\n1. 처음 - 끝 부분에 걸쳐서 점령하지 않는 경우\n2. 처음 - 끝 부분 열의 첫번째 행 칸 두곳을 한 부대가 점령하는 경우\n3. 처음 - 끝 부분 열의 두번째 행 칸 두곳을 한 부대가 점령하는 경우\n4. 2, 3 모두가 해당되는 경우.\n\n해당 되는 경우를 모두 생각하게 되면 각각의 경우에 적용해야할 초기 값이 다르단 걸 인지할 것이다.\n\n### 1의 경우의 수\n\na_1(맨앞) 과 b_1 모두 1이고, c_1은 (1, 0), (1, 1) 의 값에 따라(두 곳을 한 부대만으로 점령이 가능한지를 생각.) 2 또는 1이 결정된다.\n\n이후 점화식에 따라 DP 테이블을 채우고, `c_n` 값이 정답의 후보값이 됩니다.\n\n### 2의 경우의 수\n\na_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해줄 것이다.\n\nb_1의 경우의 수는 존재하지 않음. 이미 (1, 0) 이 점령되었기 때문에.\n\nc_1은 1이 된다. 이 또한 (1, 0) 이 점령 되었기 때문에, c_1은 이곳에 (1, 1)만을 채우는 경우 밖에 존재하지 않는다.\n\n이후 점화식에 따라 DP 테이블을 채우게 되면, (n, 0) 이 이미 점령 되어 있기 때문에, `b_n + 1` 의 값이 후보값이 됩니다! (+1을 하는 이유는 시작 시 미리 점령한 타일을 나중에 더해주기 때문입니다.)\n\n### 3의 경우의 수\n\n2와 동일하다.\n\na_1은 존재할 수 없고, b_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해준다고 가정한다.\n\nc_1은 1이된다. 이또한 위와 같은 이유에서다.\n\n2와 마찬가지로 `a_n + 1` 의 값이 후보값이 됩니다.\n\n### 4의 경우의 수\n\na_1과 b_1은 존재할 수 없고, c_1이 0이 된다.\n\n(1, 1) 과 (1, 0) 이 모두 시작 시 점령되었기 때문이다.\n\n정답의 후보값은 `c_n-1 + 2` 가 됩니다.\n\n## 내가 생각하지 못한 것\n\n### 1. 타일을 채우는 경우의 수를 잘못 나누었다.\n\n이게 무슨 소리냐면, 해당 타일이 하나만 차지하는지, 다른 타일과 나누어서 차지하고 있는지를 내가 나누었다.\n\n위와 같은 타일채우기 문제에서는 이미 차지하고 있는가 여부를 생각하고, 한번에 채울 때 나누어 채우는 방식으로 DP 테이블을 채워 나가야함을 인지하자!\n\n### 2. 원형 DP라고 생각하고 여러번 DP를 돌려야한다고 생각했다.\n\n이는 1번 문제와 같이 대응되는데, 원형 DP이고 아니고 간에, 타일을 이미 채웠다면 이를 생각할 필요 없이 그냥 경우의 수로 나누어서 풀면 되는 문제였다.\n\n## 소스 코드\n\n```cpp\n#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\n\nint dp[3][10001]; // 타일 문제 처럼 해당 행에 어느부분을 채우는가로 나누어야한다.\nint map[10001][2];\nint n, w;\n\nconst int INF = 987654321;\n\nvoid solve() {\n\t// 2열부터 시작해야함.\n\t// 그러려면 1열까진 내용을 다 채워놔야겠지\n\tfor (int i = 2; i \u003c= n; ++i) {\n\t\t// 기본값 세팅\n\t\tdp[0][i] = dp[2][i - 1] + 1;\n\t\tdp[1][i] = dp[2][i - 1] + 1;\n\t\tif (map[i][0] + map[i][1] \u003c= w) {\n\t\t\tdp[2][i] = dp[2][i - 1] + 1;\n\t\t}\n\t\telse dp[2][i] = dp[2][i - 1] + 2;\n\t\tif (map[i - 1][0] + map[i][0] \u003c= w \u0026\u0026 map[i - 1][1] + map[i][1] \u003c= w) {\n\t\t\tdp[2][i] = min(dp[2][i], dp[2][i - 2] + 2);\n\t\t}\n\n\t\tif (map[i][0] + map[i - 1][0] \u003c= w) {\n\t\t\tdp[0][i] = min(dp[0][i], dp[1][i - 1] + 1);\n\t\t}\n\t\tif (map[i][1] + map[i - 1][1] \u003c= w) {\n\t\t\tdp[1][i] = min(dp[1][i], dp[0][i - 1] + 1);\n\t\t}\n\t\t\n\t\tdp[2][i] = min(dp[2][i], min(dp[1][i] + 1, dp[0][i] + 1));\n\t}\n}\n\nint main() {\n\tcout.tie(0); cin.tie(0)-\u003esync_with_stdio(0);\n\tint tc; cin \u003e\u003e tc;\n\twhile (tc--) {\n\t\tcin \u003e\u003e n \u003e\u003e w;\n\t\t\n\t\tfor (int j = 0; j \u003c 2; ++j) {\n\t\t\tfor (int i = 1; i \u003c= n; ++i) {\n\t\t\t\tcin \u003e\u003e map[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans;\n\t\t// 시작 case 4개.\n\t\t\n\t\t// 끝 - 시작 부분에 특수부대를 걸치지 않은 경우\n\t\tfor (int i = 0; i \u003c 3; ++i)\n\t\t\tmemset(dp[i], 0, sizeof(dp[i]));\n\t\tdp[1][1] = dp[0][1] = 1; // 쌩으로 하나 채운 경우\n\t\tif (map[1][0] + map[1][1] \u003c= w) {\n\t\t\tdp[2][1] = 1;\n\t\t}\n\t\telse dp[2][1] = 2;\n\t\tsolve();\n\t\tans = dp[2][n];\n\n\t\t// 위에 만 걸친 경우\n\t\tif (map[1][0] + map[n][0] \u003c= w) {\n\t\t\tfor (int i = 0; i \u003c 3; ++i)\n\t\t\t\tmemset(dp[i], 0, sizeof(dp[i]));\n\t\t\tdp[0][1] = 0; // 초기 상태가 이미 dp[0][1] 이다.\n\t\t\tdp[1][1] = INF; // 이곳을 참조할 경우의 수가 없다.\n\t\t\tdp[2][1] = 1;\n\t\t\tsolve();\n\t\t\tans = min(ans, dp[1][n] + 1);\n\t\t}\n\t\tif (map[1][1] + map[n][1] \u003c= w) {\n\t\t\tfor (int i = 0; i \u003c 3; ++i)\n\t\t\t\tmemset(dp[i], 0, sizeof(dp[i]));\n\t\t\tdp[0][1] = INF; // 불가능\n\t\t\tdp[1][1] = 0;\n\t\t\tdp[2][1] = 1;\n\t\t\tsolve();\n\t\t\tans = min(ans, dp[0][n] + 1);\n\t\t}\n\t\tif (map[1][0] + map[n][0] \u003c= w \u0026\u0026 map[1][1] + map[n][1] \u003c= w) {\n\t\t\tfor (int i = 0; i \u003c 3; ++i)\n\t\t\t\tmemset(dp[i], 0, sizeof(dp[i]));\n\t\t\tdp[0][1] = dp[1][1] = INF; // 불가능\n\t\t\tdp[2][1] = 0;\n\t\t\tsolve();\n\t\t\tans = min(ans, dp[2][n - 1] + 2);\n\t\t}\n\t\tcout \u003c\u003c ans \u003c\u003c '\\n';\n\t}\n\n}\n```"])</script><script>self.__next_f.push([1,"a:T1818,"])</script><script>self.__next_f.push([1,"\r\n## 증상 원인\r\n\r\n내 마크다운 블로그를 개발하던 중 이게 왠일?\r\n\r\n블로그에 테마 토글 기능을 추가해서 다크모드를 사용할 때에도 라이트 모드를, 또는 그 반대를 활용할 수 있도록 만들었는데, 내가 시스템에서 설정한 테마 색이 시스템 설정을 따라 가다보니 시스템 테마가 먼저 적용이 되고, 그 다음에 토글 기능으로 설정된 테마가 나중에 적용된다.\r\n\r\n일명 깜빡거리는 증상인데 어떻게 된일인지 생각해봤다.\r\n\r\n## HTML Blocking\r\n\r\n보통 `DOM` 이 생성될 때,  중간에 script 태그를 만나게 되면 DOM 생성 과정이 중단됩니다.\r\n\r\n이걸 이용하면 body 가 처음에 흰색이던 아니던 우리가 보기전에 `head` 태그에서 배경색을 지정해버리면 처음부터 페이지 색상이 그랬던 것처럼 로딩이 잘 될거라 생각했습니다.\r\n\r\n---\r\n\r\n# 대망의 첫 시도. 그리고 실패\r\n\r\n실패했습니다. 하하. 하지만 생각보다 실패의 원인은 넥스트에 깊은 곳에 자리 잡고 있는 것으로 보입니다. 실패한 원인에 대해 얘기해보고자 합니다.\r\n\r\n## 내 index 페이지에서의 로딩 방식이 사뭇 다르다?\r\n\r\n제 블로그는 Next.js Static Site Generation을 이용합니다. 정적 페이지를 생성을 해주어 정적 페이지로도 라우팅이 가능하게끔 구성되어 있는데요. 이 방식에 따르면 제 페이지는 반드시 정적 페이지가 생성되어야 하고, 클라이언트 사이드 코드는 극소수만 존재해야했다.\r\n\r\n### 그런데 `__next_error__` 값의 `id` 속성이 html에 붙어있었다.\r\n\r\n이게 뭐지? 싶었는데 알고보니 클라이언트 단에서 에러가 난 것이였다. 이걸 어떻게 알았냐고?\r\n\r\n`Postlist` 컴포넌트를 주석처리하니 놀랍게도 해당 속성이 없이 제대로 인덱스 페이지가 렌더링 되었다. 어떻게 된 일인지 생각을 해봤는데 놀랍게도 `useSearchParam` 이 원인이였다.\r\n\r\n## 진짜는 `useSearchParam` 에 있었다..\r\n\r\n어떻게 알아냈냐면 결국 넥스트가 SSG를 할 때 나는 오류구문을 어떻게든 찾아내게 계속 빌드를 해서 알아냈는데, \r\n\r\n[Entire page deopted into client-side rendering](https://nextjs.org/docs/messages/deopted-into-client-rendering)\r\n\r\n위와 같은 사이트로 이동 되었는데 역시나,, 다른 것들도 아니고 useSearchParam 때문이였다.\r\n\r\n이게 뭐냐면 클라이언트의 페이지에 링크에 저장된 파라미터값을 가져오는 훅이다. 이걸 사용할 때 `Suspense` 로 범위를 묶어주어야 전체 CSR이 안된다고 한다.\r\n\r\n그래서 깜빡이는 현상이 생긴 것이다. 이것 때문에 CSR 렌더링이 전체 범위로 바뀌기 때문에 어떻게 똥꼬쇼를 해도 내가 만든 코드는 전부 페이지 로드가 끝이 나고 실행이 됐던 것이였다.\r\n\r\n## Suspense 가 뭔지?\r\n\r\nsuspense는 CSR이 어디서부터 어디까지 되게 할 건지 범위를 지정해주는 것이다.\r\n\r\n지금 내가 만들고 있는건 정적페이지인데, 어디서부터 `CSR`을 해야하는지 지정을 명확하게 해준다.\r\n\r\n단순히 `use client;` 를 선언한다고 이게 딱딱 맞추어 지는 건 아닌게, 아래가 `page.tsx` 인데 잘보면 `Postlist` 컴포넌트는 그냥 다른 `div` 컴포넌트와 형제 관계이므로 이 형제 관계인 요소들도 전부 CSR이 되고, 이런식으로 CSR이 타고올라가다보면 전체 범위가 CSR이 되는 것이다…!\r\n\r\n따라서 비동기로 생성되는 부분만 따로 선렌더링을 할 JSX 컴포넌트를 주고 후에 CSR로 렌더링되게 만들 게 해주는 것이 Suspense 인 것이다.\r\n\r\n```jsx\r\nimport Postlist from \"./Postlist\";\r\nimport styles from \"./page.module.css\";\r\nimport { Article, getArticleList } from \"@/ts/article\";\r\n\r\nexport default function Page() {\r\n  const articles = getArticleList();\r\n  return \u003cdiv className={styles.mainWrap}\u003e\r\n    \u003cdiv className={styles.title}\u003ePosts\u003c/div\u003e\r\n    \u003cdiv className={styles.description}\u003e다양한 주제로 글을 씁니다.\u003c/div\u003e\r\n    \u003cdiv className={styles.hr} /\u003e\r\n    \r\n    \u003cPostlist articleList={articles} /\u003e\r\n  \u003c/div\u003e\r\n}\r\n```\r\n\r\n위 코드를 아래와 같이 바꿔주었다.\r\n\r\n```jsx\r\nimport Postlist from \"./Postlist\";\r\nimport { Suspense } from \"react\";\r\nimport styles from \"./page.module.css\";\r\nimport { getArticleList } from \"@/ts/article\";\r\n\r\nfunction PostlistFallback() {\r\n  return \u003c\u003e\r\n    loading...\r\n  \u003c/\u003e\r\n}\r\n\r\nexport default function Page() {\r\n  return \u003cdiv className={styles.mainWrap}\u003e\r\n    \u003cdiv className={styles.title}\u003ePosts\u003c/div\u003e\r\n    \u003cdiv className={styles.description}\u003e다양한 주제로 글을 씁니다.\u003c/div\u003e\r\n    \u003cdiv className={styles.hr} /\u003e\r\n    \r\n    \u003cSuspense fallback={\u003cPostlistFallback /\u003e}\u003e\r\n      \u003cPostlist articleList={getArticleList()} /\u003e\r\n    \u003c/Suspense\u003e\r\n  \u003c/div\u003e\r\n}\r\n```\r\n\r\n이렇게 바꾸고나니 놀랍게도 에러가 뜨지 않고 정상적으로 정적페이지가 렌더링 되었다! 더욱 내 블로그가 최적화 되었다고 생각하니 기쁘지 않을수가 없다.\r\n\r\n아래는 `Suspense` 기능에 관한 더 자세한 AI 검색 결과이다.\r\n\r\n안녕하세요, 이것은 Bing입니다. 😊\r\n\r\nReact.js에서 Suspense는 비동기 작업을 관리하는 기능입니다. Suspense를 사용하면 컴포넌트가 데이터를 기다리고 있는 것을 React에게 알릴 수 있고, 대신에 fallback 컴포넌트를 보여줄 수 있습니다. 예를 들어, 다음과 같이 코드를 작성하면 UserList 컴포넌트가 로딩될 때까지 Spinner 컴포넌트를 보여줍니다.\r\n\r\n```jsx\r\n\u003cSuspense fallback={\u003cSpinner /\u003e}\u003e\r\n  \u003cUserList /\u003e\r\n\u003c/Suspense\u003e\r\n\r\n```\r\n\r\nSuspense는 React v16.6부터 실험적으로 도입되었고, React v18에서 정식으로 지원됩니다. Suspense를 사용하면 컴포넌트의 렌더링을 더 쉽고 세련되게 제어할 수 있습니다. Suspense에 대한 자세한 내용은 [공식 문서](https://react.dev/reference/react/Suspense)나 [이 블로그 포스트](https://www.daleseo.com/react-suspense/)를 참고하세요."])</script><script>self.__next_f.push([1,"b:Tce5,"])</script><script>self.__next_f.push([1,"\r\n## 풀이\r\n\r\n결국엔 어떻게 돌리느냐는 위 아래 눈이 무엇인지 가 중요 합니다.\r\n\r\n내말은 돌려도 변하지 않는 면이 있는데, 그 면들을 중심으로 번호가 어떻게 변하는지 4개의 수의 반복이 어케되는지를 매겨놓으면 문제해결이 가능합니다.\r\n\r\n\r\n처음 주사위 상태는\r\n\r\n```\r\n5 (굴려도 변하지 않는 앞쪽면)\r\n\r\n1 (윗면)\r\n\r\n2 (굴려도 변하지 않는 뒤쪽면)\r\n```\r\n\r\n이렇게 되고, 주사위를 굴리다가 다음 행으로 옮기게 되면 주사위의 상태는 아래처럼 변할 것입니다.\r\n\r\n```\r\n(마지막 윗면 상태 의 반대편)\r\n\r\n(이전 윗면)\r\n\r\n(마지막 윗면 상태)\r\n```\r\n\r\n또 그 다음은\r\n```\r\n(마지막 윗면 상태의 반대편)\r\n\r\nN\r\n\r\n(마지막 윗면상태)\r\n```\r\n\r\n이런식으로 반복됨을 알 수 있습니다.\r\n\r\n그렇다면, 1 4 6 3과 같은 옆면의 수열을 어떻게 구할 수 있느냐가 이제 관건인데, 사실 주사위기 때문에 경우의 수가 그렇게 많지 않습니다.\r\n\r\n저의 경우는 아예 계산을 해서 프리셋을 먼저 생성해놓고 풀었는데요, 아래와 같이 반복되는 수열이 정의됩니다.\r\n\r\n*! 오른쪽으로 굴리는 기준 !*\r\n```\r\n(5, 2) 일 경우 {1, 4, 6, 3}\r\n(2, 5) 일 경우 {1, 3, 6, 4}\r\n(1, 6) 일 경우 {3, 2, 4, 5}\r\n(6, 1) 일 경우 {3, 5, 4, 2}\r\n(3, 4) 일 경우 {1, 5, 6, 2}\r\n(4, 3) 일 경우 {1, 2, 6, 5}\r\n```\r\n\r\n## 구상한 알고리즘\r\n\r\n### 행이 홀수일 경우\r\n\r\n1. (a, b) 값을 얻는다. (이때 a와 b는 수열에 관여하지 않는 위에서 봤을때 기준 주사위의 앞, 뒷면 이다.)\t\r\n\r\n2. 이전 판의 a 값을 가져온다. 이 값이 현재 상태의 윗면이다.\r\n\r\n3. 열의 크기를 4로 나눈 몫과 14(전체 수열의 투어 결과)를 곱한 값을 결과에 더한다.\r\n\r\n4. 열의 크기를 4로 나눈 나머지값만큼 더 굴린다. `while(remain--) {}` 굴리는 원리는 첫 윗면의 idx 값을 가져와서, idx = (idx + 1) % 4; 와 같은 방식으로 더해나가면 된다.\r\n\r\n### 행일 짝수일 경우\r\n\r\n- 수열을 얻는 과정은 똑같이 진행하나, idx = (idx - 1 \u003e= 0 ? idx - 1 : 3) % 4; 과 같이 전개하면 된다.\r\n\r\n## 소스코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003cvector\u003e\r\nusing namespace std;\r\n\r\nvector\u003cint\u003e preset[7][7];\r\n\r\nint main() {\r\n\tint front = 5, back = 2;\r\n\tint up = 1;\r\n\tpreset[5][2] = { 1, 4, 6, 3 };\r\n\tpreset[2][5] = { 1, 3, 6, 4 };\r\n\tpreset[1][6] = { 3, 2, 4, 5 };\r\n\tpreset[6][1] = { 3, 5, 4, 2 };\r\n\tpreset[3][4] = { 1, 5, 6, 2 };\r\n\tpreset[4][3] = { 1, 2, 6, 5 };\r\n\r\n\tint n, m; cin \u003e\u003e n \u003e\u003e m;\r\n\r\n\tlong long ans = 0;\r\n\r\n\tfor (int i = 1; i \u003c= n; ++i) {\r\n\t\tans += (m / 4) * 14;\r\n\t\tint remain = m % 4;\r\n\t\tint idx = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c 4; ++i) {\r\n\t\t\tif (preset[front][back][i] == up) {\r\n\t\t\t\tidx = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (remain--) {\r\n\t\t\tint next_value = preset[front][back][idx];\r\n\t\t\tans += next_value;\r\n\t\t\tif (remain) {\r\n\t\t\t\tif(i%2) idx = (idx + 1) % 4;\r\n\t\t\t\telse idx = (idx - 1 \u003e= 0 ? idx - 1 : 3) % 4;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint tmp = front;\r\n\t\tback = preset[front][back][idx];\r\n\t\tup = tmp;\r\n\t\tfront = 7 - back;\r\n\t}\r\n\tcout \u003c\u003c ans;\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"c:T9df,"])</script><script>self.__next_f.push([1,"\r\n## 문제 접근\r\n\r\n오프라인 쿼리라는 개념을 알고 접근해보도록 합시다.\r\n\r\n오프라인 쿼리란 간략히 말해서, 쿼리의 전체 적용 결과 값**만** 알고 싶을 때 사용하는 전략으로,\r\n쿼리의 순서를 모두 받은 뒤, 역순으로 처리할 때, 중복처리가 되지 않는 경우 그 점을 이용하는 전략입니다.\r\n\r\n이 점을 이용해서 문제를 풀 수 있습니다.\r\n\r\n## 솔루션\r\n\r\n단, 위 개념을 알아도, 칠해져있는지 일일이 매 역순 쿼리마다 확인해나가다 보면 시간초과하기 마련입니다.\r\n\r\n따라서 `space[1 to N]` 라는 이름의 배열을 생성하여 현재 위치를 기록해도 되는지, 그게 아니라면 다음 위치는 어디가 되는지를 기록해두어야합니다.\r\n\r\n이를 구현한 방법은 분리집합에서의 `find()` 와 같습니다.\r\n\r\n일단 매 쿼리에서 주어진 `l` 과 `r` 구간에서, 우리가 칠했던 모든 지역의 `space[]` 값을 `r + 1`로 설정해둡시다.\r\n\r\n우리가 칠하는 지역의 `space[i]` 값이 `i`가 아닌 경우, 언급한 `find()` 함수를 통해 재귀적으로 호출하며 `space[]` 값을 갱신해나가면 최적화가 가능합니다.\r\n\r\n## 소스코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003cvector\u003e\r\n#include\u003cutility\u003e\r\nusing namespace std;\r\n\r\nint space[1000001]; // 1 to 1m\r\nint fibo[1000001]; // fibo value\r\nint ind[1000001]; // answer which indicates index of fibo value.\r\nconst int MOD = 1000000007;\r\n\r\nint find(int t) {\r\n\tif (space[t] == t) return t;\r\n\treturn space[t] = find(space[t]);\r\n}\r\n\r\n\r\nint main() {\r\n\tcout.tie(0); cin.tie(0)-\u003esync_with_stdio(0);\r\n\r\n\tfibo[1] = space[1] = 1;\r\n\tfibo[2] = space[2] = 2;\r\n\t\r\n\tfor (int i = 3; i \u003c= 1000000; ++i) {\r\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\r\n\t\tfibo[i] %= MOD;\r\n\t\tspace[i] = i;\r\n\t}\r\n\t\r\n\t\r\n\tint n, q; cin \u003e\u003e n \u003e\u003e q;\r\n\tvector\u003cpair\u003cint,int\u003e\u003e query;\r\n\tspace[n + 1] = n + 1;\r\n\r\n\tfor (int i = 0; i \u003c q; ++i) {\r\n\t\tint l, r; cin \u003e\u003e l \u003e\u003e r;\r\n\t\tquery.push_back({l, r});\r\n\t}\r\n\r\n\tfor (int i = query.size() - 1; i \u003e= 0; --i) {\r\n\t\tint l = query[i].first;\r\n\t\tint r = query[i].second;\r\n\t\tint next = space[l];\r\n\t\twhile (next \u003c= n \u0026\u0026 next \u003c= r) {\r\n\t\t\tnext = find(next);\r\n\t\t\tif (next \u003e r) break;\r\n\t\t\tint idx = next - l + 1;\r\n\t\t\tind[next] = idx;\r\n\t\t\tspace[next] = r + 1;\r\n\t\t\tnext++;\r\n\t\t}\r\n\t}\r\n\tfor (int i = 1; i \u003c= n; ++i) {\r\n\t\tcout \u003c\u003c fibo[ind[i]] \u003c\u003c ' ';\r\n\t}\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"d:T104c,"])</script><script>self.__next_f.push([1,"\r\n## 내가 생각한 솔루션\r\n\r\n### 1. 분리집합\r\n\r\n문제를 보자마자 일단 아! 분리집합 문제구나 라고 생각은 했음.\r\n\r\n\r\n각 영역의 분리집합을 구한 후, 분리집합의 개수 별로 nC2의 값을 표현하기 가 구현내용이 아닐지.. 하고.\r\n\r\n예를들면, 문제 예시의 트리와, `K = 6, S_k = { 1,2,3,4,5,6 }` 인 경우\r\n\r\n`{ 1, 2, 3, 5 }` 와 `{4, 6}`으로 두 영역이 나뉘므로,\r\n\r\n`4C2 + 2C2 = 6 + 1 = 7` 가 정답인 것이다.\r\n\r\n각 영역별로 수행한다고 치면 최악의 경우 O(N) 만큼 걸릴 것임.\r\n\r\n이렇게 단순하게 생각하면 사실 풀 수 있지만, 애로사항이 있다.\r\n\r\n위의 시간 복잡도는 정확하지 않다. **쿼리가 있기 때문이다.**\r\n\r\n### 2. DFS\r\n\r\n그래서 DFS로 해볼까? 하고 생각해봤다.\r\n\r\n\u003e S_K 마다 탐색을 한다.\r\n\u003e\r\n\u003e 자식노드가 없는 경우는 스킵한다.\r\n\u003e\r\n\u003e 이미 방문한 점도 스킵한다.\r\n\r\n방문 수 : `O(N)` 이기 때문에 이 방법도 사실상 최적화엔 실패다.\r\n\r\n## 해설을 통한 솔루션\r\n\r\n\r\n위 방식대로하면 결국 각 노드에서 모든 간선 을 둘러보게 되는 단점이 있고, 이는 `O(N)` 만큼 소모되게 만드는 단점이 있다.\r\n\r\n쿼리가 하나면 상관없지만 쿼리가 10만개나 되니, 결국 전체 쿼리에 등장하는 K의 개수가 최대 백만인 점을 이용해 `O(쿼리중 나오는 전체 K 집합의 원소 수)`로 단순화시켜야한다.\r\n\r\nN의 크기에 영향을 받지 않고 순수하게 K만 살펴보기 위해서는 트리의 구조를 이용해야한다.\r\n\r\n트리가 가지는 성질은 자신 노드가 루트가 아니라면, 부모노드는 오로지 하나라는 점이다.\r\n이렇게 되면 순전히 K개의 노드와, 그의 부모노드만 확인하면 되게 되므로, `O(N + 쿼리중 나오는 전체 K집합의 원소 수)`가 되게 된다.\r\n\r\n각 K의 부모노드를 확인해가면서, 분리집합으로 어떤 트리에 어떻게 속하는지 기록을 하며 루트노드가 될 노드에게 노드의 개수를 전달해주면 해결이다.\r\n\r\n트리의 특성을 활용하는 문제였다. 많이 나에겐 어려운 것 같으니 골드 하위 트리문제를 좀 더 풀어봐야할 것 같다.\r\n\r\n## 소스코드\r\n\r\n`s[]` 배열을 `memset()` 을 통해 초기화 하지 않고, 쓰고 난 후 다시 `false` 값으로 되돌려 주면 AC 시간을 많이 단축 시킬 수 있습니다.\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003cvector\u003e\r\nusing namespace std;\r\n\r\nvector\u003cint\u003e tree[250001];\r\nbool visit[250001];\r\nint parent[250001]; // 분리집합\r\nint cnt[250001]; // 각 지점을 루트로 하는 트리의 노드 개수 입니다.\r\nbool s[250001];\r\nint tree_parent[250001];\r\n\r\nvoid process(int node) {\r\n\t// dfs로 전처리 하는 과정\r\n\tvisit[node] = true;\r\n\tfor (int i : tree[node]) {\r\n\t\tif (!visit[i]) {\r\n\t\t\tprocess(i);\r\n\t\t\ttree_parent[i] = node;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint find(int t) {\r\n\tif (parent[t] == t) return t;\r\n\treturn parent[t] = find(parent[t]);\r\n}\r\n\r\nvoid uni(int a, int b) {\r\n\tif (a \u003e b) {\r\n\t\tint swp; swp = a; a = b; b = swp;\r\n\t}\r\n\tparent[b] = a;\r\n\tcnt[a] += cnt[b];\r\n\tcnt[b] = -1;\r\n}\r\n\r\nint main() {\r\n\tcin.tie(0); cout.tie(0)-\u003esync_with_stdio(0);\r\n\tint n, q;\r\n\tcin \u003e\u003e n;\r\n\tfor (int i = 0; i \u003c n - 1; ++i) {\r\n\t\tint a, b; cin \u003e\u003e a \u003e\u003e b;\r\n\t\ttree[a].push_back(b);\r\n\t\ttree[b].push_back(a);\r\n\t}\r\n\r\n\tprocess(1); // 최소 노드의 개수는 1일테니 1을 루트로 정의한다.\r\n\r\n\tcin \u003e\u003e q;\r\n\twhile (q--) {\r\n\t\tint k; cin \u003e\u003e k;\r\n\t\tvector\u003cint\u003e arr;\r\n\r\n\t\tfor (int i = 0; i \u003c k; ++i) {\r\n\t\t\tint t; cin \u003e\u003e t;\r\n\t\t\tparent[t] = t;\r\n\t\t\tcnt[t] = 1;\r\n\t\t\ts[t] = true;\r\n\t\t\tarr.push_back(t);\r\n\t\t}\r\n\r\n\t\tlong long ans = 0;\r\n\r\n\t\tfor (int t : arr) {\r\n\t\t\tif (s[tree_parent[t]]) {\r\n\t\t\t\tuni(find(t), find(tree_parent[t]));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int t : arr) {\r\n\t\t\ts[t] = false; // 쓰고 바로 마킹을 지우면 memset을 할 필요가 없어짐.\r\n\t\t\tif (cnt[t] \u003e 1) {\r\n\t\t\t\tans += (long long)cnt[t] * (cnt[t] - 1) / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcout \u003c\u003c ans \u003c\u003c '\\n';\r\n\t}\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"e:Tdca,"])</script><script>self.__next_f.push([1,"\r\n## 주의사항\r\n\r\n본 문서는 Bing AI로 작성되었으며, 작성자 참고용으로 제작된 문서입니다. 향후 저작권 이슈가 있을 경우 바로 내릴 수 있도록 하겠습니다.\r\n\r\n## 본문\r\n\r\nTypeScript에서 as 키워드는 타입 단언(type assertion)을 사용하기 위한 것입니다. 타입 단언은 컴파일러에게 변수나 속성의 타입을 우리가 지정해주는 것이며, 컴파일러가 스스로 추론하는 것을 방지합니다. 타입 단언은 any 타입을 특정 타입으로 다루는 데 자주 사용됩니다. 예를 들어, 다음과 같은 코드가 있습니다.\r\n\r\n```typescript\r\nlet x: any = \"Hello\";\r\nlet y = x as string;\r\n```\r\n\r\n여기서 `x`는 any 타입이므로, 컴파일러는 `x`가 가지고 있는 메서드나 속성에 대해 알 수 없습니다. 그래서 `x.length`나 `x.toUpperCase()`와 같은 코드는 오류를 발생시킬 수 있습니다. 하지만 `y`는 `x`를 string 타입으로 단언한 것이므로, 컴파일러는 `y`가 string 타입이라고 인식하고, string 타입의 메서드나 속성을 사용할 수 있습니다.\r\n\r\n타입 단언은 변환(conversion)이 아닙니다. 즉, as 키워드로 변수의 값을 바꾸거나 새로운 값을 만들지 않습니다. 단지 컴파일러에게 변수의 타입을 알려주는 것뿐입니다. 런타임에는 as 키워드가 아무런 영향을 주지 않습니다¹.\r\n\r\n타입 단언은 다음과 같은 두 가지 방식으로 사용할 수 있습니다.\r\n\r\n```typescript\r\n// 꺽쇠 괄호(\u003c\u003e)를 사용하는 방식\r\nlet a = \u003cstring\u003e x;\r\n\r\n// as 키워드를 사용하는 방식\r\nlet b = x as string;\r\n```\r\n\r\n두 방식은 동일한 기능을 하지만, JSX와 함께 사용할 때는 as 키워드를 사용해야 합니다². JSX는 XML과 비슷한 문법으로, React와 같은 프레임워크에서 UI 컴포넌트를 만들 때 사용합니다³.\r\n\r\n## 타입에러 방지\r\n\r\n타입 에러를 방지하기 위해서는 as 키워드를 사용하는 것이 좋지 않은 방법이라고 할 수 있습니다. as 키워드는 컴파일러에게 타입을 강제로 지정하는 것이므로, 실제로 값이 다른 타입일 경우 런타임에 에러가 발생할 수 있습니다. 예를 들어, 다음과 같은 코드가 있습니다.\r\n\r\n```typescript\r\nlet x: any = 123;\r\nlet y = x as string;\r\nconsole.log(y.length); // 런타임 에러\r\n```\r\n\r\n여기서 `x`는 any 타입이므로, `y`에 string 타입으로 단언하였습니다. 하지만 `x`의 값은 실제로 숫자이므로, `y.length`를 실행하면 런타임에 에러가 발생합니다. 이런 경우를 방지하기 위해서는 as 키워드를 사용하지 않고, 타입 가드(type guard)라는 기능을 사용하는 것이 좋습니다¹. 타입 가드는 특정 조건문을 통해 변수의 타입을 좁혀주는 것입니다. 예를 들어, 다음과 같은 코드가 있습니다.\r\n\r\n```typescript\r\nlet x: any = 123;\r\n// string이 타입이 아닌 문자열임에 주의하세요. (코멘트 직접 작성)\r\nif (typeof x === \"string\") {\r\n  console.log(x.length); // 안전하게 실행\r\n}\r\n```\r\n\r\n여기서 `typeof x === \"string\"`이라는 조건문은 `x`가 string 타입일 때만 참이 되므로, 컴파일러는 이 조건문 안에서 `x`의 타입을 string으로 인식합니다. 따라서 `x.length`를 안전하게 실행할 수 있습니다.\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"f:T1287,"])</script><script>self.__next_f.push([1,"\r\n드로우 온 웹 프로젝트를 현재 `vite + react + typescript`로 진행중입니다.\r\n\r\n하다가 문제점이 생긴게, 캔버스 토글을 `animation`을 주면서 껐다켰다하는 기능을 만드는 중이넫 여기서 문제가 생기더라고요\r\n\r\n`eventlistener` 를 삭제하려면 해당 함수가 무결해야 하고, 함수가 특정 변수에 정의되어 있어 지정할 수 있어야합니다..\r\n\r\n그런데, 제가 마우스 이벤트를 사용하던 함수들은 모두 리액트 훅으로 반환되는 `ref` 객체를 사용하고 있었습니다...\r\n\r\n이렇게 되면 해당 함수들을 모두 `toggleCanvas` 내에 정의를 해야하는데, 그렇게되면 함수가 너무 길어져서 코드의 가독성이 작살나버리더라고요.\r\n\r\n```ts\r\nfunction toggleCanvas(params:toggleCanvasParams) {\r\n  const {ctx, status} = params;\r\n  const prevX = useRef\u003cnumber\u003e(0);\r\n  const prevY = useRef\u003cnumber\u003e(0);\r\n\r\n  const contextMenuTimer = useRef\u003cnumber\u003e(0);\r\n  const pressed = useRef\u003cboolean\u003e(false);\r\n\r\n  if (status) {\r\n    ctx.canvas.classList.add(\"hide-canvas\");\r\n    // first click events\r\n    window.addEventListener(\"mousedown\", (e) =\u003e {\r\n      if (e.button != 2) return;\r\n      pressed.current = true;\r\n      prevX.current = e.pageX;\r\n      prevY.current = e.pageY;\r\n    });\r\n\r\n    // mouse release events\r\n    window.addEventListener(\"mouseup\", (e) =\u003e {\r\n      if (e.button != 2) return;\r\n      pressed.current = false;\r\n    });\r\n\r\n    // drawing events.\r\n    window.addEventListener(\"mousemove\", (e) =\u003e {\r\n      if (!pressed.current) return;\r\n      if (!ctx) return;\r\n      contextMenuTimer.current++;\r\n      doBrush(ctx, prevX, prevY, e);\r\n    });\r\n\r\n    // about context menu popup\r\n    window.addEventListener(\"contextmenu\", (e) =\u003e {\r\n      if (contextMenuTimer.current \u003e= 10) e.preventDefault();\r\n      contextMenuTimer.current = 0;\r\n    });\r\n  } else {\r\n    ctx.canvas.classList.add(\"hide-canvas\");\r\n    // 여기선 어떻게 해야하지?!\r\n  }\r\n}\r\n```\r\n\r\n## 내가 해결한 방법\r\n\r\n위와 같은 방법으로 해도 removeEventListener는 동작하지 않습니다.\r\n\r\nremoveEventListener를 사용하기 위해선 함수가 한번만 정의되어야합니다.\r\n\r\n따라서,\r\n\r\n1. 중첩함수 (함수가 호출될때마다 정의됨)\r\n2. 익명함수 (함수가 메모리에 매번 새롭게 assign됨)\r\n\r\n는 사용할 수 없습니다.\r\n\r\n클로저를 이용하여 전역에 접근할 EventContext 클래스를 정의하고, 함수들 또한 전역 스코프에 선언해주어 유일한 객체로 만들어야합니다.\r\n\r\n아래는 예시입니다.\r\n\r\n```ts\r\n// 이벤트 객체에 클로저로 직접 주입한 객체. 근데 이게 맞는지 모르겠다.\r\nclass EventContext {\r\n  static params: toggleCanvasParams;\r\n  static setParam(params:toggleCanvasParams): void {\r\n    EventContext.params = params;\r\n  }\r\n}\r\n\r\nfunction doBrush(params: doBrushParams) { ... }\r\n\r\n\r\nfunction handleMouseDown(e: MouseEvent) {\r\n  const {pressed, prevX, prevY} = EventContext.params;\r\n  if (e.button != 2) return;\r\n  pressed.current = true;\r\n  prevX.current = e.pageX;\r\n  prevY.current = e.pageY;\r\n}\r\n\r\nfunction handleMouseUp(e: MouseEvent) {\r\n  const {pressed} = EventContext.params;\r\n  if (e.button != 2) return;\r\n  pressed.current = false;\r\n}\r\n\r\nfunction handleMouseMove(e :MouseEvent) {\r\n  const {pressed, contextMenuTimer, ctx, prevX, prevY} = EventContext.params;\r\n  if (!pressed.current) return;\r\n  contextMenuTimer.current++;\r\n  doBrush({ctx, prevX, prevY, event:e});\r\n}\r\n\r\nfunction handleRightClick(e: MouseEvent) {\r\n  const {contextMenuTimer} = EventContext.params;\r\n  if (contextMenuTimer.current \u003e= 10) e.preventDefault();\r\n  contextMenuTimer.current = 0;\r\n}\r\n\r\nexport function toggleCanvas(params:toggleCanvasParams) {\r\n  EventContext.setParam(params);\r\n  const {ctx, status} = params;\r\n\r\n  if (status) {\r\n    ctx.canvas.classList.remove(\"hide-canvas\");\r\n\r\n    window.addEventListener(\"mousedown\", handleMouseDown);\r\n    window.addEventListener(\"mouseup\", handleMouseUp);\r\n    window.addEventListener(\"mousemove\", handleMouseMove);\r\n    window.addEventListener(\"contextmenu\", handleRightClick);\r\n\r\n  } else {\r\n    ctx.canvas.classList.add(\"hide-canvas\");\r\n    \r\n    window.removeEventListener(\"mousedown\", handleMouseDown);\r\n    window.removeEventListener(\"mouseup\", handleMouseUp);\r\n    window.removeEventListener(\"mousemove\", handleMouseMove);\r\n    window.removeEventListener(\"contextmenu\", handleRightClick);\r\n  }\r\n}\r\n```\r\n\r\n여기서 더 나아가서 핸들러들을 EventContext의 메소드로 선언해도 가능한지 한번 연구중에 있습니당\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"10:T827,"])</script><script>self.__next_f.push([1,"\r\n## 나의 접근\r\n\r\n이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데\r\n도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다...\r\n\r\n스택의 특징을 아직 잘 몰라서 실수를 했는데, 스택이 사용될 수 있는 상황은 다음과 같습니다.\r\n\r\n- 현재 문제 상황이 선형적이지만, 여태까지 내가 \"탐색\"했던 정보들을 바탕으로 판단해야할 때,\r\n\r\n- 혹은 탐색했지만 정답을 찾지못한 정보들을 모아두었다가 나중에 일괄적으로 문제를 해결할 수 있을 때,\r\n\r\n- 그 외 느낌상으로 모아두었다가 해결할 수 있을 것 같을 때\r\n\r\n한번 쯤 생각해보면 좋을 것 같습니다. 스택..실제로 활용 문제를 실전풀이로 할 때 상당히 어려운 것 같습니다.\r\n\r\n## 알고리즘\r\n\r\n1. 현재 수를 보고 다음 수를 본다, 다음 수가 더 크다면, 기본적으로 현재 수의 NGE는 다음 수이다.\r\n\r\n2. 만약 다음 수가 더 작다면, 현재수를 push 하고 다음 수를 본다.\r\n\r\n3. 1의 과정 중, 다음 수가 현재수보다 크다면, 현재 수의 NGE는 다음 수 이다, 또한 스택이 비지 않았을 때, top이 현재 시점의 다음 수보다 작을 경우, 해당 수의 NGE도 현재 시점의 다음 수이다.\r\n\r\n## 소스코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003cstack\u003e\r\n#include\u003cvector\u003e\r\nusing namespace std;\r\n\r\nint main() {\r\n\tcout.tie(0); cin.tie(0)-\u003esync_with_stdio(0);\r\n\tint n; cin \u003e\u003e n;\r\n\tvector\u003cint\u003e arr(n);\r\n\tvector\u003cint\u003e ans(n, -1);\r\n\tstack\u003cint\u003e st;\r\n\r\n\tfor (int i = 0; i \u003c n; ++i) {\r\n\t\tcin \u003e\u003e arr[i];\r\n\t}\r\n\t\r\n\tfor (int i = 0; i \u003c n - 1; ++i) {\r\n\t\tif (arr[i + 1] \u003e arr[i]) {\r\n\t\t\tans[i] = arr[i + 1];\r\n\t\t\twhile (!st.empty() \u0026\u0026 arr[st.top()] \u003c arr[i + 1]) {\r\n\t\t\t\tans[st.top()] = arr[i + 1];\r\n\t\t\t\tst.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (arr[i + 1] \u003c= arr[i]) {\r\n\t\t\tst.push(i);\r\n\t\t}\r\n\t}\r\n\tfor (int t : ans) {\r\n\t\tcout \u003c\u003c t \u003c\u003c ' ';\r\n\t}\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"11:T598,"])</script><script>self.__next_f.push([1,"\r\n### 소스 코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\nusing namespace std;\r\n\r\nint n, k, l;\r\nstring input;\r\n\r\nint u[10001][10001];\r\nint dp[10001]; // 유사 펠린드롬의 여부 = 1 이상이면 해당, 또 1 이상인 값이 여러개 일 경우 가장 적은 값 입니다.\r\n\r\nint getU(int s, int e) {\r\n\tif (s \u003e= e) return 0;\r\n\tif (u[s][e]) return u[s][e];\r\n\tif (input[s] != input[e]) return 0;\r\n\treturn u[s][e] = 1 + getU(s + 1, e - 1);\r\n}\r\n\r\nbool is_theta(int s, int e) {\r\n\tif (s == e) return false;\r\n\r\n\tint len = e - s + 1;\r\n\tint v_len = getU(s, e);\r\n\r\n\tif (k*len \u003c= 2 * v_len * l) return true;\r\n\treturn false;\r\n}\r\n\r\nint main() {\r\n\tcin \u003e\u003e n \u003e\u003e k \u003e\u003e l \u003e\u003e input;\r\n\r\n\tfor (int i = 0; i \u003c n; ++i) {\r\n\t\tdp[i] = -1;\r\n\r\n\t\tif (is_theta(0, i)) dp[i] = 1;\r\n\r\n\t\tfor (int j = 1; j \u003c i; ++j) {\r\n\t\t\t// 끝점이 i인 경우를 모두 검색하다보면 dp 값을 한번만 방문할 수 있을 것이다.\r\n\t\t\t// 1 ~ j / j + 1 ~ i 이렇게 두개로 나눔.\r\n\t\t\t// 더 작은 segment로 나뉠 수 있는 것 아닌가? -\u003e 그 경우는 이미 dp[a][b] : b가 i보다 작은 경우에서 모두 구했음.\r\n\t\t\tif (is_theta(j, i) \u0026\u0026 dp[j - 1] \u003e 0) {\r\n\t\t\t\tif (dp[i] \u003e 1 + dp[j - 1] || dp[i] == -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tdp[i] = dp[j - 1] + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tcout \u003c\u003c ((dp[n - 1] == -1) ? 0 : dp[n - 1]);\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"12:T1874,"])</script><script>self.__next_f.push([1,"\r\n## 접근\r\n\r\n\r\n처음 접근은 이랬습니다. 사실 제일 처음에 어려웠던 부분은 d-정상이 무엇인지 이해를 하는 것이였습니다.\r\n\r\nd만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데,\r\n잘못된 방법이였습니다.\r\n\r\n땅에서부터 d 만큼의 높이차가 존재하는 지역이 정상이라고 생각할 수 없는 이유는, 해당하는 높은 지역 사이에 그 지역보다 더 높은 지역이 있을지도 모르기 때문입니다.\r\n\r\n예를들어, 해당 지점이 땅이 아닌 지점이면서 (h-d)보다 더 낮은 지점이 방문 가능한 봉우리 h가 있다고 하면 어떻게 될까요?\r\n\r\n그림으로 설명해보겠습니다.\r\n\r\n```\r\n- 제일 높은 위치 (0)\r\n\t\t\t            ---           ==\u003e 여긴 d 정상임 (1)\r\n\t\t                | -\u003e d보다 작음\r\n            ------  ===========\u003e 여긴 d 정상이 아님. (2)\r\n            | -\u003e d보다 큼.\r\n---- 땅 -\r\n```\r\n\r\n```\r\n1\r\n2 4 2\r\n5 0 3 4\r\n```\r\n\r\n가장 높은 지점에서만 bfs하면  (1)이 d-정상임을 판별할 수 없고,\r\n\r\n땅에서부터 bfs하면 (2)가 d-정상이 아님을 판별할 수 없습니다.\r\n\r\n따라서 저희는 모든 점을 찾아볼 수 밖에 없습니다.\r\n\r\n다만, 그중에서 가장 높은 \"정상\"부터 BFS해야합니다. d-정상의 정의에 따르면 높이가 어떻든, 가장 높은 점은 자신보다 더 높은 점이 존재하지 않기 때문에 주어진 맵에서 가장 높은 높이를 부여받은 지점은 무조건 d-정상에 해당됩니다.\r\n\r\n일단 가장 높은 지점에서부터 높이차가 d보다 작은 지점들을 bfs 하면서 visit 을 했다는 표식을 남깁시다.\r\n\r\n이 표식이 그 다음으로 가장 높은 지점에서  높이차가 d보다 작은 지점들을 bfs를 하다가 사전에 방문했던 지점들을 만난다면, 그것은 d-정상의 정의에 위배됩니다. 따라서 해당 bfs시작점을 비롯한 bfs 중 만났던 해당 bfs 시점 중 가장 높은 지점들 전부 d-정상에 위배됩니다.\r\n\r\n현재 bfs 중 방문햇던 지점과, 이전에 이미 방문했었던 지점을 구별하기 위해 `visit` 값은 `bool`이 아닌 `int` 값을 사용했습니다.\r\n\r\n## 구현\r\n\r\n1. 가장 높은 지역을 BFS 한다.\r\n\r\n2. 닿지 않는 지역 중 그다음으로 가장 높은 지역을 BFS 한다. // 각 세그 먼트 중 자신보다 높은 지역이 닿이는 세그먼트는 d 정상이 아니다.\r\n\r\n3. `queue`를 sorting 할거면.. `priority queue`를 사용.\r\n\r\nPQ를 사용한 뒤, 일단 visit 배열을 정상값으로 칠합니다. 이게 무슨 소리냐면, 3 이 정상이라 하면, 최소 (3 - d)인 지점을 모두 bfs 해가며 해당 부분의 visit 값은 가장 높은 정상의 값으로 정한다는 뜻입니다.\r\n\r\n만약 해당 bfs segment 도중에 자신보다 높은 지점을 나타내는 , 해당 bfs 서브프로세스에서 얻는 d-정상의 개수는 무조건 0으로 합니다. 단, 추후 bfs 할 프로세스에서 가장 높은 h는 현재의 h보다 작기 때문에 bfs 세그먼트를 계속해야합니다.\r\n\r\n도중에 자신과 같은 높이의 지점을 만났다면 bfs segment 에서 더할 d-정상의 개수를 1 늘립니다.\r\n\r\n도중에 라벨된 지점을 만났다면 해당 segment에서 얻는 d-정상의 개수는 0입니다. 왜냐하면 지점이 높은순으로 라벨링을 했기 때문입니다.\r\n\r\n## 내가 계속 틀렸던 이유\r\n\r\n### board를 클리어하지 않아서 계속 틀렸었다.\r\n\r\n이때 `vector`를 써야하는 이유를 알았습니다.\r\n\r\nvector 가 갖는 또 다른 이점은 로컬 변수로 선언함으로써 반복문 내에서도 부담없이 memset할 필요가 없었고, 무엇보다 스택 영역을 차지하지 않음으로써 스택오버플로우도 면할 수 있었습니다. 여러모로 상당히 고마운 존재입니다.\r\n\r\n### board[n+2][m+2] 와 같은 형식으로 구현하고자 하는 경우\r\n\r\n이럴땐 board[][]의 경계선을 확실히 해주도록합시다. 문제에선 0이 가장 낮은 땅이므로 경계선과 땅을 구별할 수 없습니다.\r\n\r\n따라서 입력된 board[][] 값을 모두 1씩 올려줌으로써 해결했습니다.\r\n\r\n\r\n## 소스코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003cqueue\u003e\r\n#include\u003ccstring\u003e\r\nusing namespace std;\r\ntypedef pair\u003cint, int\u003e pii;\r\n\r\nint board[502][502];\r\nint visit[502][502] = { 0, };\r\nint dir[4][2] = {\r\n\t{0, 1},\r\n\t{0, -1},\r\n\t{1, 0},\r\n\t{-1, 0}\r\n};\r\n\r\nint n, m, d, total;\r\npriority_queue\u003cpair\u003cint, pii\u003e\u003e pq;\r\nqueue\u003cpii\u003e bfs_q;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tint t; cin \u003e\u003e t;\r\n\twhile (t--) {\r\n\t\ttotal = 0;\r\n\t\tcin \u003e\u003e n \u003e\u003e m \u003e\u003e d;\r\n\t\tfor (int i = 0; i \u003c= n + 1; ++i) {\r\n\t\t\tmemset(visit[i], 0, sizeof(visit[i]));\r\n\t\t\tmemset(board[i], 0, sizeof(board[i]));\r\n\t\t}\r\n\r\n\t\tfor (int i = 1; i \u003c= n; ++i) {\r\n\t\t\tfor (int j = 1; j \u003c= m; ++j) {\r\n\t\t\t\tcin \u003e\u003e board[i][j];\r\n\t\t\t\tboard[i][j]++;\r\n\t\t\t\tif (board[i][j]) {\r\n\t\t\t\t\tpq.push({ board[i][j], {i, j} });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint visit_seg = 0;\r\n\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tint d_summit = 1;\r\n\t\t\tvisit_seg++;\r\n\t\t\tint h = pq.top().first;\r\n\t\t\tint st_x = pq.top().second.second;\r\n\t\t\tint st_y = pq.top().second.first;\r\n\t\t\tpq.pop();\r\n\r\n\t\t\tif (visit[st_y][st_x]) continue;\r\n\t\t\tvisit[st_y][st_x] = visit_seg;\r\n\r\n\t\t\tbfs_q.push({ st_y, st_x });\r\n\r\n\t\t\twhile (!bfs_q.empty()) {\r\n\t\t\t\tint y = bfs_q.front().first;\r\n\t\t\t\tint x = bfs_q.front().second;\r\n\t\t\t\tbfs_q.pop();\r\n\r\n\t\t\t\tfor (int i = 0; i \u003c 4; ++i) {\r\n\t\t\t\t\tint dy = y + dir[i][0];\r\n\t\t\t\t\tint dx = x + dir[i][1];\r\n\r\n\t\t\t\t\tif (!board[dy][dx]) continue;\r\n\r\n\t\t\t\t\tif (visit[dy][dx] \u0026\u0026 visit[dy][dx] \u003c visit_seg) {\r\n\t\t\t\t\t\td_summit = 0;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (visit[dy][dx] == visit_seg) continue;\r\n\r\n\t\t\t\t\tif (board[dy][dx] == h) {\r\n\t\t\t\t\t\tif (d_summit) d_summit++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!visit[dy][dx] \u0026\u0026 board[dy][dx] \u003e h - d) {\r\n\t\t\t\t\t\tvisit[dy][dx] = visit_seg;\r\n\t\t\t\t\t\tbfs_q.push({ dy, dx });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttotal += d_summit;\r\n\t\t}\r\n\r\n\t\tcout \u003c\u003c total \u003c\u003c '\\n';\r\n\t}\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!\r\n\r\n"])</script><script>self.__next_f.push([1,"13:T13b8,"])</script><script>self.__next_f.push([1,"\r\n## `next_permutation()` 이란?\r\n\r\n알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다. 물론 \r\n이런 경우는 사실 대부분 재귀함수를 사용하다보면 해결이 되는 경우가 많습니다.\r\n\r\n하지만 재귀를 통한 경우의 수 추출의 경우, 모든 경우의 수의 처리를 위해서는 해당 함수 호출스택 내에서 외부 변수에 모두 모아놓거나, 각각의 경우의 수가 완성된 경우의 함수 스택 상태 위에서 작업을 실행해야 모든 경우의 수에 대한 대응이 가능합니다.\r\n\r\n간단한 처리의 경우는 상관 없지만, `스택 오버플로우` 와 같은 오류를 내고 싶지 않은 상황이거나 재귀 함수를 사용 하는 것에 대해 약간 민감한 상황이라면, `next_permutation` 을 사용하는 것이 좋다고 생각합니다.\r\n\r\n`next_permutation()` 함수는 `algorithm` 내 헤더에 있으며, 보통은 함수의 인자로 `iterator` 의 처음 부분과 끝 부분을 넣습니다.\r\n\r\n이때 `iterator` 의 개념에 대해 간단히 이야기하자면, 그냥 배열의 요소를 가르킨다고 보시면 됩니다. `C++`을 알고리즘 문제풀이로 사용하는 입장에서는 일반적인 배열과 `vector` 의 처음과 끝 포인터가 들어간다고 생각하면 됩니다.\r\n\r\n해당 함수가 호출되면, 함수의 인자로 들어간 `배열 객체의 다음 순열의 순서`로 변경해줍니다. 이때 정의된 배열의 순열의 순서는 오름차순이 기준입니다.\r\n\r\n예를 들어, `0 0 1` 의 순열을 오름차순으로 나열하였을 때, 해당 배열의 다음 순열은 `0 1 0` 일 겁니다. 그 다음은 `1 0 0` 일 것입니다.\r\n\r\n따라서 보통 일반적으로 `next_permutation()`을 호출하기 전에 오름차순에 따라 **정렬을 해두고 사용 해야 모든 순열의 경우의 수를 확인할 수 있습니다.**\r\n\r\n## 조합을 뽑는 방법\r\n\r\n`next_permutation` 에서는 값이 같은 배열의 요소를 동일한 원소로 취급합니다. 이 점을 이용하여 조합을 만들 수도 있습니다.\r\n\r\n이게 무슨 뜻이냐면, `0(1번째 원소) 0(2번째 원소) 1` 이라는 내용의 배열이 있다면, `0` 두개가 동일원소로 취급되지 않는 중복 순열 이라면 다음 순열은 `0(2번째 원소) 0(1번째 원소) 1` 이 다음 순열이여야합니다. 하지만 `next_permuation` 에서는 중복을 허용하지 않는 순열을 반환하기 때문에 중복 원소에 대한 순열은 스킵이 됩니다.\r\n\r\n이를 통해 조합을 구성하는 방법은 간단합니다. 뽑는가, 뽑지 않는가 여부만 판단하는 것이 조합이므로, 뽑는 수만큼 `1`, 뽑지 않는 수만큼 `0`으로 구성된 0-1 배열을 구성하여 `next_permutation` 함수를 호출 하면, 모든 조합의 경우의 수를 알 수 있습니다.\r\n\r\n## 응용\r\n\r\n해당 문제는 응용입니다. 문제를 풀고 밑부분을 참고하세요.\r\n\r\n- [[ 백준 18809 ] Gaaaaarden : C++ 풀이](https://chayhan.github.io/markdown-blog/2023-10-20-boj18809)\r\n\r\n\r\n### 활용 설명\r\n\r\n위에서 조합을 응용하는 방법은 그렇습니다.\r\n\r\n조합을 두번 뽑지 않고, 중복순열이 아닌 점을 활용하는 겁니다.\r\n\r\n땅이 5개, 그중에 빨간 배양액 2곳과 초록 배양액 2곳을 사용한다고 하는 예제 입력이 있다고 합시다. 그런 경우에 `0 1 1 2 2` 와 같은 배열의 순열을 순회하면 배양액을 뿌리는 모든 경우의 수를 저희는 확인할 수가 있을 것입니다.\r\n\r\n위와 같은 방식으로 문제를 활용할 수도 있을 것입니다.\r\n\r\n## 코드 짜는 법\r\n\r\n이제부터는 실제 코드 사용법에 대해 알아보겠습니다.\r\n\r\n익숙치 않는 문법을 사용할 건데요. `do - while` 문을 사용할 것입니다. 그것에는 이유가 있습니다. `sort` 를  통해 순열을 확인할 배열을 정렬했다면, 일단 맨 첫번째 순열은 이미 정렬된 해당 배열이기 때문에 해당 구문을 이용해 일단 확인해도 모든 경우의 수를 확인할 수 있기 때문입니다.\r\n\r\n`while`문의 조건 문에서 next_permutation()을 호출하면 현재 해당 배열이 마지막 순열( = 현재 배열이 내림차순인지)인지 아닌지에 따라 `return` 값이 달라집니다.\r\n\r\n마지막 순열이라면 false를 출력하기 때문에 순열을 순회하기도 쉽습니다.\r\n\r\n1. 배열 구성하기\r\n2. `sort` 하기\r\n3. `do - while` 구문으로  순회하기\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003calgorithm\u003e\r\nusing namespace std;\r\n\r\nint main() {\r\n    int arr[5];\r\n    for (int i = 0; i \u003c 5; ++i) {\r\n        arr[i] = i + 1;\r\n    }\r\n    sort(arr, arr + 5);\r\n    do {\r\n\r\n        for (auto i : arr) {\r\n            cout \u003c\u003c i \u003c\u003c ' ';\r\n        }\r\n        cout \u003c\u003c '\\n';\r\n    } while (next_permutation(arr, arr + 5));\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"14:T932,"])</script><script>self.__next_f.push([1,"### 소스코드\r\n\r\n```cpp\r\n#include\u003ciostream\u003e\r\n#include\u003calgorithm\u003e\r\n#include\u003ccstring\u003e\r\n#include\u003cqueue\u003e\r\nusing namespace std;\r\n\r\nint n, m;\r\nint r, g;\r\nint board[52][52]; // 맵\r\n\r\nvector\u003cpair\u003cint, int\u003e\u003e able_list; // 배양액 뿌릴 수 있는 땅 정보\r\n\r\nint dir[4][2] = {\r\n\t{0, 1},\r\n\t{1, 0},\r\n\t{0, -1},\r\n\t{-1, 0}\r\n};\r\n\r\nint flowers; // 꽃의 개수\r\n\r\nvoid bfs(vector\u003cpair\u003cint, int\u003e\u003e\u0026 gv, vector\u003cpair\u003cint, int\u003e\u003e\u0026 rv) {\r\n\tint visit[52][52] = { 0, }; // 빨간색 -t 값. 초록색 t 값으로 시간을 표현. 1초부터 시작. 0이면 닿지않은 경우임.\r\n\tint f = 0; // 현재 꽃\r\n\tqueue\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e q; // bfs q\r\n\r\n\tfor (auto t : gv) {\r\n\t\tvisit[t.first][t.second] = -1;\r\n\t\tq.push({ -1, t });\r\n\t}\r\n\r\n\tfor (auto t : rv) {\r\n\t\tvisit[t.first][t.second] = 1;\r\n\t\tq.push({ 1, t });\r\n\t}\r\n\r\n\twhile (!q.empty()) {\r\n\t\tint time = q.front().first;\r\n\t\tpair\u003cint, int\u003e node = q.front().second; q.pop();\r\n\r\n\t\tint y = node.first;\r\n\t\tint x = node.second;\r\n\r\n\t\tif (visit[y][x] == 9999) continue; // 꽃은 퍼지지 않음.\r\n\r\n\t\tvisit[y][x] = time;\r\n\r\n\t\tif (time \u003e 0) time++;\r\n\t\telse time--;\r\n\r\n\t\tfor (int i = 0; i \u003c 4; ++i) {\r\n\t\t\tint dy = y + dir[i][0];\r\n\t\t\tint dx = x + dir[i][1];\r\n\r\n\t\t\tif (visit[dy][dx] + time == 0) {\r\n\t\t\t\tvisit[dy][dx] = 9999;\r\n\t\t\t\tf++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (board[dy][dx] \u0026\u0026 visit[dy][dx] == 0) {\r\n\t\t\t\tq.push({ time, {dy, dx} });\r\n\t\t\t\tvisit[dy][dx] = time;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tflowers = flowers \u003c f ? f : flowers;\r\n}\r\n\r\nint main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcin \u003e\u003e n \u003e\u003e m \u003e\u003e r \u003e\u003e g;\r\n\tfor (int i = 1; i \u003c= n; ++i) {\r\n\t\tfor (int j = 1; j \u003c= m; ++j) {\r\n\t\t\tcin \u003e\u003e board[i][j];\r\n\t\t\tif (board[i][j] == 2) {\r\n\t\t\t\table_list.push_back({ i, j });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tvector\u003cint\u003e p;\r\n\tfor (int i = 0; i \u003c able_list.size() - r - g; ++i) p.push_back(0);\r\n\tfor (int i = 0; i \u003c r; ++i) p.push_back(1);\r\n\tfor (int i = 0; i \u003c g; ++i) p.push_back(2);\r\n\r\n\tdo {\r\n\r\n\t\tvector\u003cpair\u003cint, int\u003e\u003e r_list;\r\n\t\tvector\u003cpair\u003cint, int\u003e\u003e g_list;\r\n\r\n\t\tfor (int i = 0; i \u003c p.size(); ++i) {\r\n\t\t\tif (p[i] == 1) r_list.push_back(able_list[i]);\r\n\t\t\tif (p[i] == 2) g_list.push_back(able_list[i]);\r\n\t\t}\r\n\r\n\t\tbfs(g_list, r_list);\r\n\r\n\t} while (next_permutation(p.begin(), p.end()));\r\n\r\n\tcout \u003c\u003c flowers;\r\n}\r\n```\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"15:T93f,"])</script><script>self.__next_f.push([1,"## 이미지 가져오기\r\n\r\n이미지를 가져오는 건 리액트처럼 그냥 해당  프로젝트 내에서도 가져올 수 있는데 문제는 asset들은 모두 `public` 폴더 를 root로 하기 때문에 해당 폴더 내에만 배치를 해야한다.\r\n\r\n본 문서들도 모두 public 에 배치된 이유가 그렇기 때문이다.\r\n\r\n## 동적 라우팅\r\n\r\n동적 라우팅은 app router 에서는 이전 레거시 버전처럼 폴더 이름의 양 끝을 대괄호로 감싼 다음, 그 안의 `page.ts` 에서 `params` 라는 속성을 받게 만든다면 알아서 서버 컴포넌트에서 params 에 폴더 이름에 대응하는 값을 params 에 해당 폴더 이름으로 속성으로 넣어준다.\r\n\r\n## 페이지의 타이틀 변경\r\n\r\n타이틀 부분은 중요하다.\r\n\r\n같은 솔루션 페이지를 여러군데를 띄워놓앗을 때 어떤 탭의 페이지가 어떤 내용을 함축하고있는지 나타내주어야하는데 가장 간단한 방법이 타이틀을 바꾸는 방법이다. \r\n\r\n- 해결방법 : `\u003cHead\u003e` 기능을 사용하면 된다.\r\n\r\n일단 아래처럼 가져온다.\r\n\r\n```js\r\nimport Head from 'next/head'\r\n```\r\n\r\n그런데 알고보니 이게 app router 에서는 이렇게 사용하지 않는다고 한다.\r\n\r\n![Alt text](image.png)\r\n\r\n해결방법은 아래와 같이 Metadata 값을 재정의 해주는 것만으로 새롭게 바뀌는 가보다. 작동방식이 상당히 특이하다. 아마 해당 Functional Component의 default export 값만 보는게 아닌 것 같다.\r\n\r\n![Alt text](image-1.png)\r\n\r\n## Typescript on React : 자식 설정\r\n\r\n`This JSX tag's 'children' prop expects a single child of type 'ReactElement\u003cany, string | JSXElementConstructor\u003cany\u003e\u003e', but multiple children were provided.`\r\n\r\n위와 관련된 에러 해결이다.\r\n\r\n아래와 같이 설정하자.\r\n\r\n```js\r\nchildren: JSX.Element|JSX.Element[];\r\n```\r\n\r\n### Typescript 에서 React Children 설정 방법\r\n\r\n총 3가지가 있음.\r\n\r\n- React.ReactNode\r\n- JSX.Element \r\n- React.ReactElement\r\n\r\n\r\n이렇게 3가지가 있는데, React.ReactNode를 사용하면 `string`, `number`를 비롯한 JSX 노드들을 중복/단일 상관없이 받기 때문에, `React.ReactNode` 를 사용하면 됩니다.\r\n\r\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/markdown-blog/_next/static/css/1d5397ff1d0b753b.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/markdown-blog/_next/static/css/6d5e3c23a0d301f9.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"a24zhBtUQbqn9uDoUbObu\",\"assetPrefix\":\"/markdown-blog\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"__PAGE__\",{},[\"$L6\",[\"$\",\"div\",null,{\"className\":\"page_mainWrap__G2_gf\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page_title__3jonF\",\"children\":\"Posts\"}],[\"$\",\"div\",null,{\"className\":\"page_description__86bsR\",\"children\":\"다양한 주제로 글을 씁니다.\"}],[\"$\",\"div\",null,{\"className\":\"page_hr__LC6V_\"}],[\"$\",\"$7\",null,{\"fallback\":\"loading...\",\"children\":[\"$\",\"$L8\",null,{\"articleList\":[{\"slug\":\"2023-12-26-boj1006\",\"content\":\"$9\",\"title\":\"[ 백준 1006 ] 습격자 초라기 : C++ 풀이\",\"date\":\"$D2023-12-26T00:00:00.000Z\",\"description\":\"백준 1006번 문제 풀이 입니다.\",\"dateString\":\"Dec 26, 2023\"},{\"slug\":\"2023-12-25-darkmode-flickering\",\"content\":\"$a\",\"title\":\"다크모드 테마 시 깜빡거리는 증상\",\"date\":\"$D2023-12-25T00:00:00.000Z\",\"description\":\"내가 시스템에서 설정한 테마 색이 먼저 적용이 되고, 그 다음에 다크 모드로 설정된 테마가 나중에 적용되는 현상\",\"dateString\":\"Dec 25, 2023\"},{\"slug\":\"2023-11-16-boj2818\",\"content\":\"$b\",\"title\":\"[ 백준 2818 ] 숙제하기 싫을 때 : C++ 풀이\",\"date\":\"$D2023-11-16T00:00:00.000Z\",\"description\":\"백준 2818 풀이입니다.\",\"dateString\":\"Nov 16, 2023\"},{\"slug\":\"2023-11-16-boj26087\",\"content\":\"$c\",\"title\":\"[ 백준 26087 ] 피보나치와 마지막 수열과 쿼리 : C++ 풀이\",\"date\":\"$D2023-11-16T00:00:00.000Z\",\"description\":\"백준 26087 풀이입니다.\",\"dateString\":\"Nov 16, 2023\"},{\"slug\":\"2023-11-15-text-underline\",\"content\":\"\\r\\ntext-underline의 상세한 조절이 가능합니다.\\r\\n\\r\\n## underline의 굵기 설정\\r\\n\\r\\n```css\\r\\ntext-decoration-thickness: 0;\\r\\n```\\r\\n\\r\\n## underline의 위치 조절\\r\\n\\r\\n```css\\r\\ntext-underline-offset: 5px;\\r\\n```\\r\\n\\r\\n참고할 수 있도록 게시함.\\r\\n\\r\\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!\",\"title\":\"[ CSS ] text underline 의 높이 조절, 굵기 설정하기\",\"date\":\"$D2023-11-15T00:00:00.000Z\",\"description\":\"text-underline의 상세한 스타일을 조절할 수 있습니다.\",\"dateString\":\"Nov 15, 2023\"},{\"slug\":\"2023-11-12-query-tree\",\"content\":\"$d\",\"title\":\"[ 백준 25402 ] 트리와 쿼리 : C++ 풀이\",\"date\":\"$D2023-11-12T00:00:00.000Z\",\"description\":\"트리의 특성을 이용한 연결그래프 탐색문제입니다.\",\"dateString\":\"Nov 12, 2023\"},{\"slug\":\"2023-11-03-typescript-interface\",\"content\":\"$e\",\"title\":\"[ TS ] 타입스크립트에서 타이핑 하기 귀찮은데요 (Typescript as 키워드)\",\"date\":\"$D2023-11-03T00:00:00.000Z\",\"description\":\"TypeScript에서 as 키워드는 타입 단언(type assertion)을 사용하기 위한 것입니다.\",\"dateString\":\"Nov 3, 2023\"},{\"slug\":\"2023-10-31-remove-event\",\"content\":\"$f\",\"title\":\"[ React ] 이벤트 탈착할 때 주의 사항\",\"date\":\"$D2023-10-31T00:00:00.000Z\",\"description\":\"드로우 온 웹 크롬 익스텐션 사이드 프로젝트 중에 생긴 문제입니다.\",\"dateString\":\"Oct 31, 2023\"},{\"slug\":\"2023-10-25-boj17298\",\"content\":\"$10\",\"title\":\"[ 백준 17298 ] 오큰수 : C++ 풀이\",\"date\":\"$D2023-10-25T00:00:00.000Z\",\"description\":\"이분탐색도 생각해보고, 뒤에서부터 진행도 생각해봤는데 도저히 감이 잡히질 않아서 주제를 봤더니 스택문제였습니다.\",\"dateString\":\"Oct 25, 2023\"},{\"slug\":\"2023-10-24-boj13330\",\"content\":\"$11\",\"title\":\"[ 백준 13330 ] 유사 팰린드롬 : C++ 풀이\",\"date\":\"$D2023-10-24T00:00:00.000Z\",\"description\":\"소스코드만 있습니다.\",\"dateString\":\"Oct 24, 2023\"},{\"slug\":\"2023-10-23-boj3697\",\"content\":\"$12\",\"title\":\"[ 백준 3697 ] 정상 : C++ 풀이\",\"date\":\"$D2023-10-23T00:00:00.000Z\",\"description\":\"d만큼의 높이차가 존재하는 정상들은 모두 정상이다라고 생각을 해서 땅에서부터 그냥 bfs하면 되는것 아닌가 싶은데, 잘못된 방법이였습니다.\",\"dateString\":\"Oct 23, 2023\"},{\"slug\":\"2023-10-21-next-permutation\",\"content\":\"$13\",\"title\":\"[ C++ ] 조합, 순열 을 next_permutation() 으로 순회하기\",\"date\":\"$D2023-10-21T00:00:00.000Z\",\"description\":\"알고리즘을 하다보면 저희가 모든 경우의 수를 뽑아서 봐야할 때가 있습니다.\",\"dateString\":\"Oct 21, 2023\"},{\"slug\":\"2023-10-20-boj18809\",\"content\":\"$14\",\"title\":\"[ 백준 18809 ] Gaaaaarden : C++ 풀이\",\"date\":\"$D2023-10-20T00:00:00.000Z\",\"description\":\"소스코드만 있습니다.\",\"dateString\":\"Oct 20, 2023\"},{\"slug\":\"2023-10-14-lis\",\"content\":\"## 풀이\\r\\n\\r\\n풀이는 제 이전 블로그에서 확인 가능합니다.\\r\\n\\r\\n## [소스코드 : LIS 3](https://boj.kr/12783)\\r\\n\\r\\n```cpp\\r\\n#include\u003ciostream\u003e\\r\\nusing namespace std;\\r\\n\\r\\nint n, len;\\r\\n\\r\\nint arr[1000000];\\r\\nint lis[1000000];\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\r\\n\\tcin \u003e\u003e n;\\r\\n\\r\\n\\tfor (int i = 0; i \u003c n; ++i) cin \u003e\u003e arr[i];\\r\\n\\r\\n\\tlen = 1;\\r\\n\\tlis[0] = arr[0];\\r\\n\\t\\r\\n\\tfor (int i = 1; i \u003c n; ++i) {\\r\\n\\t\\tint l = 0;\\r\\n\\t\\tint h = len;\\r\\n\\t\\tint upper_bound = h;\\r\\n\\r\\n\\t\\twhile (l \u003c= h) {\\r\\n\\t\\t\\tint mid = (l + h) / 2;\\r\\n\\t\\t\\tif (lis[mid] \u003c arr[i]) {\\r\\n\\t\\t\\t\\tl = mid + 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if (lis[mid] \u003e= arr[i]) {\\r\\n\\t\\t\\t\\tupper_bound = mid;\\r\\n\\t\\t\\t\\th = mid - 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlis[upper_bound] = arr[i];\\r\\n\\t\\tif (len == upper_bound) {\\r\\n\\t\\t\\tlen += 1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\tcout \u003c\u003c len;\\r\\n}\\r\\n```\\r\\n\\r\\n## 주의점\\r\\n\\r\\n### `upper bound`를 확실히 구할 것!\\r\\n\\r\\n해당 값을 제대로 구했는지 확인할 요소\\r\\n\\r\\n1. `while(lo \u003c hi)` 가 아니라 `while(lo \u003c= hi)` 인지\\r\\n\\r\\n```\\r\\n7\\r\\n4 5 6 1 2 3 4\\r\\n\\r\\n정답 : 4\\r\\n```\\r\\n\\r\\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!\",\"title\":\"LIS 알고리즘 개념\",\"date\":\"$D2023-10-14T00:00:00.000Z\",\"description\":\"풀이는 제 이전 블로그에서 확인 가능합니다.\",\"dateString\":\"Oct 14, 2023\"},{\"slug\":\"2023-10-12-nojekyll\",\"content\":\"# `.nojekyll` 설정하기\\r\\n\\r\\n이거 때문에 하루를 날려먹었다.\\r\\n\\r\\n`gh-pages` 를 통해 호스팅하는 모든 페이지들은 `jekyll` 블로그 설정에 따라 호스팅 되는 경우가 많아, 깃허브에서\\r\\n자체적으로 `_next` 와 같은 디렉토리를 차단시켜버리는 경향이 있습니다.\\r\\n\\r\\n이를 막기위해서 gh-pages에 deploy할 branch의 루트폴더에 `.nojekyll` 이라는 이름의 파일을 두어 깃허브가\\r\\n해당 정적페이지는 제킬이 아님을 알려주어야 인식이 정상적으로 된다.\\r\\n\\r\\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!\",\"title\":\"깃허브 페이지에서 _next/ 폴더에 접근할 수 없는 경우\",\"date\":\"$D2023-10-12T00:00:00.000Z\",\"description\":\".nojekyll 설정하기\",\"dateString\":\"Oct 12, 2023\"},{\"slug\":\"2023-10-12-boj11401\",\"content\":\"## 설명\\r\\n\\r\\n일단 이 문제를 풀기 위해선 `페르마의 소정리`와 `모듈러 역원`을 구하는 연산을 할줄 알아야한다.\\r\\n\\r\\n\\r\\n\\r\\n### 소스코드\\r\\n\\r\\n```cpp\\r\\n#include\u003ciostream\u003e\\r\\nusing namespace std;\\r\\n\\r\\nint n, r;\\r\\nint fact[4000001];\\r\\nconst long long MOD = 1000000007;\\r\\n\\r\\nlong long getFact(long long n) {\\r\\n\\tif (n == 0) return 1;\\r\\n\\tif (fact[n]) return fact[n];\\r\\n\\treturn fact[n] = n * (long long)getFact(n - 1) % MOD;\\r\\n}\\r\\n\\r\\nlong long power(long long base, int exp) {\\r\\n\\tif (!exp) return 1;\\r\\n\\tlong long i = 1;\\r\\n\\twhile (exp) {\\r\\n\\t\\tif (exp % 2) {\\r\\n\\t\\t\\ti *= base;\\r\\n\\t\\t\\ti %= MOD;\\r\\n\\t\\t\\texp--;\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\tbase *= base;\\r\\n\\t\\tbase %= MOD;\\r\\n\\t\\texp /= 2;\\r\\n\\t}\\r\\n\\treturn i;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin \u003e\u003e n \u003e\u003e r;\\r\\n\\tlong long numer = getFact(n);\\r\\n\\tlong long deno = getFact(r) * getFact(n - r) % MOD;\\r\\n\\tdeno = power(deno, MOD - 2);\\r\\n\\tnumer = numer * deno % MOD;\\r\\n\\tcout \u003c\u003c numer;\\r\\n}\\r\\n```\\r\\n\\r\\n\u003e 보다 자세한 설명이 필요하신가요? `giscus`로 댓글을 남겨주시면 언제든지 토론이 가능합니다!\",\"title\":\"[ 백준 11401 ] 이항 계수 3 : C++ 풀이\",\"date\":\"$D2023-10-12T00:00:00.000Z\",\"description\":\"일단 이 문제를 풀기 위해선 페르마의 소정리와 모듈러 역원을 구하는 연산을 할줄 알아야한다.\",\"dateString\":\"Oct 12, 2023\"},{\"slug\":\"2023-10-11-next-js-blog\",\"content\":\"$15\",\"title\":\"[Next.js] 블로그 만들 때 생긴 에러 해결방안들 임시 메모\",\"date\":\"$D2023-10-11T00:00:00.000Z\",\"description\":\"이미지 가져오기, 동적 라우팅, 페이지 타이틀 변경 등\",\"dateString\":\"Oct 11, 2023\"},{\"slug\":\"2023-10-11-hello-world\",\"content\":\"\\r\\n# 제목1\\r\\n\\r\\n## 제목 2\\r\\n\\r\\n### 제목 3\\r\\n\\r\\n#### 제목 4\\r\\n\\r\\n\u003e 인용 태그\\r\\n\\r\\n안녕하세요.\\r\\n\\r\\n`Code`\\r\\n\\r\\n```cpp\\r\\nprintf(\\\"code\\\");\\r\\n```\\r\\n\\r\\n[link](\\\"/\\\")\\r\\n\\r\\nanything else?\\r\\n\\r\\n블로그의 탄생을 축하하며.\",\"title\":\"Hello, World!\",\"date\":\"$D2023-10-11T00:00:00.000Z\",\"description\":\"블로그의 탄생을 축하하며.\",\"dateString\":\"Oct 11, 2023\"},{\"slug\":\"2023-10-11-disjoint-set\",\"content\":\"분리집합의 구현에 관해서는 `union-find` 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.\\r\\n\\r\\n문제를 풀다가 이번에도 같은 방식으로 틀려서 기록하게 되었다.\\r\\n\\r\\n```cpp\\r\\nparent[t1] = p2;\\r\\n```\\r\\n\\r\\n위와 같이 바꾸게 되면, t1의 부모까지 부모값이 p2로 갱신되지 않고 짤리므로 위와 같이 구현하면 안된다.\\r\\n\\r\\n따라서 아래와 같이 그냥 부모노드의 부모값을 바꿔주어야한다.\\r\\n\\r\\n```cpp\\r\\nint t1 = edges[i - 1].first, t2 = edges[i - 1].second;\\r\\nint p1 = getParent(t1);\\r\\nint p2 = getParent(t2);\\r\\nif (p1 == p2) {\\r\\n    // if point, memo it and break.\\r\\n    point = i;\\r\\n    break;\\r\\n}\\r\\nif (p1 \u003c p2) {\\r\\n    parent[p2] = p1;\\r\\n}\\r\\nelse {\\r\\n    parent[p1] = p2;\\r\\n}\\r\\n```\",\"title\":\"분리 집합 구현 시 주의 점\",\"date\":\"$D2023-10-11T00:00:00.000Z\",\"description\":\"분리집합의 구현에 관해서는 union-find 방식을 사용하여 구현할 수 있는데, 그 중 UNION 하는 과정에서 주의할 필요가 있다.\",\"dateString\":\"Oct 11, 2023\"}]}]}]]}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":false,\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"script\",null,{\"type\":\"text/javascript\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n    let localTheme = localStorage.getItem(\\\"theme\\\");\\n    if(!localTheme) {\\n      localTheme = window.matchMedia(\\\"(prefers-color-scheme: dark)\\\").matches ? \\\"dark\\\" : \\\"light\\\";\\n      localStorage.setItem(\\\"theme\\\", localTheme);\\n    }\\n    \\n    const html = document.querySelector(\\\"html\\\");\\n    html.dataset.theme = localTheme;\"}}]}],[\"$\",\"body\",null,{\"className\":\"__className_e3dc15 layout_layout__dCqca\",\"children\":[\"$\",\"div\",null,{\"id\":\"layout_layout__dCqca\",\"children\":[[\"$\",\"div\",null,{\"className\":\"SideMenu_wrap__S7Kks\",\"children\":[[\"$\",\"$L16\",null,{\"className\":\"SideMenu_logoLink__h5lXm\",\"href\":\"/\",\"children\":[\"$\",\"span\",null,{\"className\":\"SideMenu_logoCharacter___HzC9\",\"children\":\"Chayhan.\"}]}],[\"$\",\"$L17\",null,{\"className\":\"SideMenu_pfp__Hne0u\",\"width\":130,\"height\":130,\"src\":\"https://avatars.githubusercontent.com/u/65532873?v=4\",\"alt\":\"profile-picture-error\"}],[\"$\",\"div\",null,{\"className\":\"SideMenu_title__9PGW3\",\"children\":\"Chayhan’s blog\"}],[\"$\",\"div\",null,{\"className\":\"SideMenu_desc__hXAjA\",\"children\":\"이 녀석에게 친추 줘서 무료로 훈수 주기\"}],[\"$\",\"div\",null,{\"className\":\"SideMenu_links__tV5ui\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"$\",\"$L16\",null,{\"href\":\"https://github.com/chayhan\",\"children\":\"Github\"}]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"$L16\",null,{\"href\":\"https://discord.gg/w8xnMDgcxA\",\"children\":\"Discord\"}]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"$L16\",null,{\"href\":\"https://solved.ac/profile/blu3fishez\",\"children\":\"Solved.ac\"}]}]]}]]}],[\"$\",\"div\",null,{\"id\":\"layout_contentWrap__twyu_\",\"children\":[[\"$\",\"div\",null,{\"id\":\"layout_content__jhh_K\",\"children\":[[\"$\",\"div\",null,{\"id\":\"layout_article__X_X3Z\",\"children\":[[\"$\",\"div\",null,{\"className\":\"nav-container\",\"children\":[\"$\",\"$L18\",null,{}]}],[\"$\",\"div\",null,{\"id\":\"$undefined\",\"children\":[\"$\",\"$L19\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L1a\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/markdown-blog/_next/static/css/6faf9db9f4b4400b.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"Toc_wrap__P1Agf\",\"children\":[[\"$\",\"div\",null,{\"children\":\"최근 읽은 글\"}],[\"$\",\"hr\",null,{}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":\"현재 기능 개발 중\"}]}]]}]]}],[\"$\",\"footer\",null,{\"className\":\"Footer_footer__Gowxd undefined\",\"children\":[\"$\",\"div\",null,{\"className\":\"Footer_footerWrap__EVpy3\",\"children\":[[\"$\",\"p\",null,{\"className\":\"Footer_supportLog__zX5GZ\",\"children\":[\"Support me by following on\",[\"$\",\"a\",null,{\"href\":\"https://github.com/chayhan\",\"children\":[[\"$\",\"$L17\",null,{\"className\":\"Footer_githubLogo__v_D4v\",\"src\":\"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/github-icon.png\",\"alt\":\"favicon\",\"width\":23,\"height\":23}],[\"$\",\"span\",null,{\"style\":{\"textDecorationLine\":\"underline\"},\"children\":\"github\"}]]}]]}],[\"$\",\"p\",null,{\"className\":\"Footer_copyright__G_vwC\",\"children\":\"© 2023 chayhan, Powered by github.io\"}]]}]}]]}]]}]}]]}],null]],\"initialHead\":[false,\"$L1b\"],\"globalErrorComponent\":\"$1c\"}]]\n"])</script><script>self.__next_f.push([1,"1b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Main :: chayhan's Blog --\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"개발자 chayhan 의 블로그 입니다.\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"chay의 깃허브 블로그\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"chayhan.github.io 블로그\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:site_name\",\"content\":\"chayhan's blog\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:title\",\"content\":\"chay의 깃허브 블로그\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:description\",\"content\":\"chayhan.github.io 블로그\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:image\",\"content\":\"https://raw.githubusercontent.com/chayhan/markdown-blog/main/public/ogimage.png\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/markdown-blog/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>