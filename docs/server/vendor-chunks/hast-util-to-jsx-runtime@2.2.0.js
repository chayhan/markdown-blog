"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-to-jsx-runtime@2.2.0";
exports.ids = ["vendor-chunks/hast-util-to-jsx-runtime@2.2.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/hast-util-to-jsx-runtime@2.2.0/node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-jsx-runtime@2.2.0/node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! comma-separated-tokens */ \"(rsc)/./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(rsc)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(rsc)/./node_modules/.pnpm/property-information@6.4.0/node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! property-information */ \"(rsc)/./node_modules/.pnpm/property-information@6.4.0/node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! property-information */ \"(rsc)/./node_modules/.pnpm/property-information@6.4.0/node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! space-separated-tokens */ \"(rsc)/./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-object */ \"(rsc)/./node_modules/.pnpm/style-to-object@0.4.4/node_modules/style-to-object/index.mjs\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-position */ \"(rsc)/./node_modules/.pnpm/unist-util-position@5.0.0/node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vfile-message */ \"(rsc)/./node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('./components.js').Components} Components\n */ /**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   An element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\n * @returns {JSX.Element}\n *   An element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | undefined, [prop: string]: Array<Child> | Child | Element | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > ðŸ‘‰ **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */ /**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */ \n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/** @type {Map<string, number>} */ const emptyMap = new Map();\nconst cap = /[A-Z]/g;\nconst dashSomething = /-([a-z])/g;\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set([\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tfoot\",\n    \"tr\"\n]);\nconst tableCellElement = new Set([\n    \"td\",\n    \"th\"\n]);\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */ function toJsxRuntime(tree, options) {\n    if (!options || options.Fragment === undefined) {\n        throw new TypeError(\"Expected `Fragment` in options\");\n    }\n    const filePath = options.filePath || undefined;\n    /** @type {Create} */ let create;\n    if (options.development) {\n        if (typeof options.jsxDEV !== \"function\") {\n            throw new TypeError(\"Expected `jsxDEV` in options when `development: true`\");\n        }\n        create = developmentCreate(filePath, options.jsxDEV);\n    } else {\n        if (typeof options.jsx !== \"function\") {\n            throw new TypeError(\"Expected `jsx` in production options\");\n        }\n        if (typeof options.jsxs !== \"function\") {\n            throw new TypeError(\"Expected `jsxs` in production options\");\n        }\n        create = productionCreate(filePath, options.jsx, options.jsxs);\n    }\n    /** @type {State} */ const state = {\n        Fragment: options.Fragment,\n        ancestors: [],\n        components: options.components || {},\n        create,\n        elementAttributeNameCase: options.elementAttributeNameCase || \"react\",\n        filePath,\n        ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n        passKeys: options.passKeys !== false,\n        passNode: options.passNode || false,\n        schema: options.space === \"svg\" ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n        stylePropertyNameCase: options.stylePropertyNameCase || \"dom\",\n        tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n    };\n    const result = one(state, tree, undefined);\n    // JSX element.\n    if (result && typeof result !== \"string\") {\n        return result;\n    }\n    // Text node or something that turned into nothing.\n    return state.create(tree, state.Fragment, {\n        children: result || undefined\n    }, undefined);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function one(state, node, key) {\n    if (node.type === \"element\" || node.type === \"root\") {\n        const parentSchema = state.schema;\n        let schema = parentSchema;\n        if (node.type === \"element\" && node.tagName.toLowerCase() === \"svg\" && parentSchema.space === \"html\") {\n            schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n            state.schema = schema;\n        }\n        state.ancestors.push(node);\n        let children = createChildren(state, node);\n        const props = createProperties(state, state.ancestors);\n        let type = state.Fragment;\n        state.ancestors.pop();\n        if (node.type === \"element\") {\n            if (children && tableElements.has(node.tagName)) {\n                children = children.filter(function(child) {\n                    return typeof child === \"string\" ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true;\n                });\n            }\n            if (own.call(state.components, node.tagName)) {\n                const key = /** @type {keyof JSX.IntrinsicElements} */ node.tagName;\n                type = state.components[key];\n                // If this is swapped out for a component:\n                if (typeof type !== \"string\" && type !== state.Fragment && state.passNode) {\n                    props.node = node;\n                }\n            } else {\n                type = node.tagName;\n            }\n        }\n        if (children.length > 0) {\n            const value = children.length > 1 ? children : children[0];\n            if (value) {\n                props.children = value;\n            }\n        }\n        // Restore parent schema.\n        state.schema = parentSchema;\n        return state.create(node, type, props, key);\n    }\n    if (node.type === \"text\") {\n        return node.value;\n    }\n}\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */ function productionCreate(_, jsx, jsxs) {\n    return create;\n    /** @type {Create} */ function create(_, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const fn = isStaticChildren ? jsxs : jsx;\n        return key ? fn(type, props, key) : fn(type, props);\n    }\n}\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */ function developmentCreate(filePath, jsxDEV) {\n    return create;\n    /** @type {Create} */ function create(node, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node);\n        return jsxDEV(type, props, key, isStaticChildren, {\n            columnNumber: point ? point.column - 1 : undefined,\n            fileName: filePath,\n            lineNumber: point ? point.line : undefined\n        }, undefined);\n    }\n}\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */ function createChildren(state, node) {\n    /** @type {Array<Child>} */ const children = [];\n    let index = -1;\n    /** @type {Map<string, number>} */ // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n    /* c8 ignore next */ const countsByTagName = state.passKeys ? new Map() : emptyMap;\n    while(++index < node.children.length){\n        const child = node.children[index];\n        /** @type {string | undefined} */ let key;\n        if (state.passKeys && child.type === \"element\") {\n            const count = countsByTagName.get(child.tagName) || 0;\n            key = child.tagName + \"-\" + count;\n            countsByTagName.set(child.tagName, count + 1);\n        }\n        const result = one(state, child, key);\n        if (result !== undefined) children.push(result);\n    }\n    return children;\n}\n/**\n * Handle properties.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Parents>} ancestors\n *   Stack of parents.\n * @returns {Props}\n *   Props for runtime.\n */ function createProperties(state, ancestors) {\n    const node = ancestors[ancestors.length - 1];\n    /** @type {Props} */ const props = {};\n    /** @type {string} */ let prop;\n    if (\"properties\" in node && node.properties) {\n        /** @type {string | undefined} */ let alignValue;\n        for(prop in node.properties){\n            if (prop !== \"children\" && own.call(node.properties, prop)) {\n                const result = createProperty(state, ancestors, prop, node.properties[prop]);\n                if (result) {\n                    const [key, value] = result;\n                    if (state.tableCellAlignToStyle && key === \"align\" && typeof value === \"string\" && tableCellElement.has(node.tagName)) {\n                        alignValue = value;\n                    } else {\n                        props[key] = value;\n                    }\n                }\n            }\n        }\n        if (alignValue) {\n            // Assume style is an object.\n            const style = /** @type {Style} */ props.style || (props.style = {});\n            style[state.stylePropertyNameCase === \"css\" ? \"text-align\" : \"textAlign\"] = alignValue;\n        }\n    }\n    return props;\n}\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Parents>} ancestors\n *   Stack of parents.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */ function createProperty(state, ancestors, prop, value) {\n    const info = (0,property_information__WEBPACK_IMPORTED_MODULE_4__.find)(state.schema, prop);\n    // Ignore nullish and `NaN` values.\n    if (value === null || value === undefined || typeof value === \"number\" && Number.isNaN(value)) {\n        return;\n    }\n    if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value);\n    }\n    // React only accepts `style` as object.\n    if (info.property === \"style\") {\n        let styleObject = typeof value === \"object\" ? value : parseStyle(state, ancestors, String(value));\n        if (state.stylePropertyNameCase === \"css\") {\n            styleObject = transformStylesToCssCasing(styleObject);\n        }\n        return [\n            \"style\",\n            styleObject\n        ];\n    }\n    return [\n        state.elementAttributeNameCase === \"react\" && info.space ? property_information__WEBPACK_IMPORTED_MODULE_7__.hastToReact[info.property] || info.property : info.attribute,\n        value\n    ];\n}\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Nodes>} ancestors\n *   Stack of nodes.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */ function parseStyle(state, ancestors, value) {\n    /** @type {Style} */ const result = {};\n    try {\n        (0,style_to_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value, replacer);\n    } catch (error) {\n        if (!state.ignoreInvalidStyle) {\n            const cause = /** @type {Error} */ error;\n            const message = new vfile_message__WEBPACK_IMPORTED_MODULE_8__.VFileMessage(\"Cannot parse `style` attribute\", {\n                ancestors,\n                cause,\n                source: \"hast-util-to-jsx-runtime\",\n                ruleId: \"style\"\n            });\n            message.file = state.filePath || undefined;\n            message.url = \"https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute\";\n            throw message;\n        }\n    }\n    return result;\n    /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */ function replacer(name, value) {\n        let key = name;\n        if (key.slice(0, 2) !== \"--\") {\n            if (key.slice(0, 4) === \"-ms-\") key = \"ms-\" + key.slice(4);\n            key = key.replace(dashSomething, toCamel);\n        }\n        result[key] = value;\n    }\n}\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */ function transformStylesToCssCasing(domCasing) {\n    /** @type {Style} */ const cssCasing = {};\n    /** @type {string} */ let from;\n    for(from in domCasing){\n        if (own.call(domCasing, from)) {\n            cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n        }\n    }\n    return cssCasing;\n}\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */ function transformStyleToCssCasing(from) {\n    let to = from.replace(cap, toDash);\n    // Handle `ms-xxx` -> `-ms-xxx`.\n    if (to.slice(0, 3) === \"ms-\") to = \"-\" + to;\n    return to;\n}\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */ function toCamel(_, $1) {\n    return $1.toUpperCase();\n}\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */ function toDash($0) {\n    return \"-\" + $0.toLowerCase();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lQDIuMi4wL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2TEMsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFeUQ7QUFDWDtBQUNrQjtBQUNQO0FBQ2Y7QUFDRztBQUNKO0FBRTFDLE1BQU1XLE1BQU0sQ0FBQyxFQUFFQyxjQUFjO0FBRTdCLGdDQUFnQyxHQUNoQyxNQUFNQyxXQUFXLElBQUlDO0FBRXJCLE1BQU1DLE1BQU07QUFDWixNQUFNQyxnQkFBZ0I7QUFFdEIsa0VBQWtFO0FBQ2xFLDZFQUE2RTtBQUM3RSwyRUFBMkU7QUFDM0UsUUFBUTtBQUVSLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsNkRBQTZEO0FBQzdELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQUM7SUFBUztJQUFTO0lBQVM7SUFBUztDQUFLO0FBRXhFLE1BQU1DLG1CQUFtQixJQUFJRCxJQUFJO0lBQUM7SUFBTTtDQUFLO0FBRTdDOzs7Ozs7Ozs7O0NBVUMsR0FFTSxTQUFTRSxhQUFhQyxJQUFJLEVBQUVDLE9BQU87SUFDeEMsSUFBSSxDQUFDQSxXQUFXQSxRQUFRQyxRQUFRLEtBQUtDLFdBQVc7UUFDOUMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0lBRUEsTUFBTUMs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Ozs7Ozs7O0NBT0MsR0FDRCxTQUFTRixPQUFPRyxFQUFFO0lBQ2hCLE9BQU8sTUFBTUEsR0FBRy9ELFdBQVc7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZG93bi1ibG9nLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1qc3gtcnVudGltZUAyLjIuMC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL2xpYi9pbmRleC5qcz8wYWNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLkVsZW1lbnR9IEVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Ob2Rlc30gTm9kZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5QYXJlbnRzfSBQYXJlbnRzXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgncHJvcGVydHktaW5mb3JtYXRpb24nKS5TY2hlbWF9IFNjaGVtYVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcG9uZW50cy5qcycpLkNvbXBvbmVudHN9IENvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtKU1guRWxlbWVudCB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IENoaWxkXG4gKiAgIENoaWxkLlxuICpcbiAqIEBjYWxsYmFjayBDcmVhdGVcbiAqICAgQ3JlYXRlIHNvbWV0aGluZyBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uLlxuICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICogICBoYXN0IG5vZGUuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRnJhZ21lbnQgc3ltYm9sIG9yIHRhZyBuYW1lLlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgUmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAncmVhY3QnfSBFbGVtZW50QXR0cmlidXRlTmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzLlxuICpcbiAqICAgSFRNTCBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGNsYXNzYCwgYHN0cm9rZS1saW5lY2FwYCwgYHhtbDpsYW5nYC5cbiAqICAgUmVhY3QgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBjbGFzc05hbWVgLCBgc3Ryb2tlTGluZWNhcGAsIGB4bWxMYW5nYC5cbiAqXG4gKiBAdHlwZWRlZiB7W3N0cmluZywgVmFsdWVdfSBGaWVsZFxuICogICBQcm9wZXJ0eSBmaWVsZC5cbiAqXG4gKiBAdHlwZWRlZiB7dW5rbm93bn0gRnJhZ21lbnRcbiAqICAgUmVwcmVzZW50IHRoZSBjaGlsZHJlbiwgdHlwaWNhbGx5IGEgc3ltYm9sLlxuICpcbiAqIEBjYWxsYmFjayBKc3hcbiAqICAgQ3JlYXRlIGEgcHJvZHVjdGlvbiBlbGVtZW50LlxuICogQHBhcmFtIHt1bmtub3dufSB0eXBlXG4gKiAgIEVsZW1lbnQgdHlwZTogYEZyYWdtZW50YCBzeW1ib2wsIHRhZyBuYW1lIChgc3RyaW5nYCksIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7UHJvcHN9IHByb3BzXG4gKiAgIEVsZW1lbnQgcHJvcHMsIGBjaGlsZHJlbmAsIGFuZCBtYXliZSBgbm9kZWAuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2tleV1cbiAqICAgRHluYW1pY2x5IGdlbmVyYXRlZCBrZXkgdG8gdXNlLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBBbiBlbGVtZW50IGZyb20geW91ciBmcmFtZXdvcmsuXG4gKlxuICogQGNhbGxiYWNrIEpzeERldlxuICogICBDcmVhdGUgYSBkZXZlbG9wbWVudCBlbGVtZW50LlxuICogQHBhcmFtIHt1bmtub3dufSB0eXBlXG4gKiAgIEVsZW1lbnQgdHlwZTogYEZyYWdtZW50YCBzeW1ib2wsIHRhZyBuYW1lIChgc3RyaW5nYCksIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7UHJvcHN9IHByb3BzXG4gKiAgIEVsZW1lbnQgcHJvcHMsIGBjaGlsZHJlbmAsIGFuZCBtYXliZSBgbm9kZWAuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIER5bmFtaWNseSBnZW5lcmF0ZWQga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGF0aWNDaGlsZHJlblxuICogICBXaGV0aGVyIHR3byBvciBtb3JlIGNoaWxkcmVuIGFyZSBwYXNzZWQgKGluIGFuIGFycmF5KSwgd2hpY2ggaXMgd2hldGhlclxuICogICBganN4c2Agb3IgYGpzeGAgd291bGQgYmUgdXNlZC5cbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqICAgSW5mbyBhYm91dCBzb3VyY2UuXG4gKiBAcGFyYW0ge3VuZGVmaW5lZH0gc2VsZlxuICogICBOb3RoaW5nICh0aGlzIGlzIHVzZWQgYnkgZnJhbWV3b3JrcyB0aGF0IGhhdmUgY29tcG9uZW50cywgd2UgZG9u4oCZdCkuXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gKiAgIEFuIGVsZW1lbnQgZnJvbSB5b3VyIGZyYW1ld29yay5cbiAqXG4gKiBAdHlwZWRlZiB7e2NoaWxkcmVuPzogQXJyYXk8Q2hpbGQ+IHwgQ2hpbGQsIG5vZGU/OiBFbGVtZW50IHwgdW5kZWZpbmVkLCBbcHJvcDogc3RyaW5nXTogQXJyYXk8Q2hpbGQ+IHwgQ2hpbGQgfCBFbGVtZW50IHwgVmFsdWUgfCB1bmRlZmluZWR9fSBQcm9wc1xuICogICBQcm9wZXJ0aWVzIGFuZCBjaGlsZHJlbi5cbiAqXG4gKiBAdHlwZWRlZiBSZWd1bGFyRmllbGRzXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1BhcnRpYWw8Q29tcG9uZW50cz4gfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tcG9uZW50c11cbiAqICAgQ29tcG9uZW50cyB0byB1c2UgKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7RWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZT0ncmVhY3QnXVxuICogICBTcGVjaWZ5IGNhc2luZyB0byB1c2UgZm9yIGF0dHJpYnV0ZSBuYW1lcyAoZGVmYXVsdDogYCdyZWFjdCdgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ZpbGVQYXRoXVxuICogICBGaWxlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChvcHRpb25hbCkuXG4gKlxuICogICBQYXNzZWQgaW4gc291cmNlIGluZm8gdG8gYGpzeERFVmAgd2hlbiB1c2luZyB0aGUgYXV0b21hdGljIHJ1bnRpbWUgd2l0aFxuICogICBgZGV2ZWxvcG1lbnQ6IHRydWVgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2lnbm9yZUludmFsaWRTdHlsZT1mYWxzZV1cbiAqICAgSWdub3JlIGludmFsaWQgQ1NTIGluIGBzdHlsZWAgcHJvcHMgKGRlZmF1bHQ6IGBmYWxzZWApO1xuICogICB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byB0aHJvdyBhbiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXNzS2V5cz10cnVlXVxuICogICBHZW5lcmF0ZSBrZXlzIHRvIG9wdGltaXplIGZyYW1ld29ya3MgdGhhdCBzdXBwb3J0IHRoZW0gKGRlZmF1bHQ6IGB0cnVlYCkuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IFNvbGlkIGN1cnJlbnRseSBmYWlscyBpZiBrZXlzIGFyZSBwYXNzZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFzc05vZGU9ZmFsc2VdXG4gKiAgIFBhc3MgdGhlIGhhc3QgZWxlbWVudCBub2RlIHRvIGNvbXBvbmVudHMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtTcGFjZSB8IG51bGwgfCB1bmRlZmluZWR9IFtzcGFjZT0naHRtbCddXG4gKiAgIFdoZXRoZXIgYHRyZWVgIGlzIGluIHRoZSBgJ2h0bWwnYCBvciBgJ3N2ZydgIHNwYWNlIChkZWZhdWx0OiBgJ2h0bWwnYCkuXG4gKlxuICogICBXaGVuIGFuIGA8c3ZnPmAgZWxlbWVudCBpcyBmb3VuZCBpbiB0aGUgSFRNTCBzcGFjZSwgdGhpcyBwYWNrYWdlIGFscmVhZHlcbiAqICAgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byBhbmQgZnJvbSB0aGUgU1ZHIHNwYWNlIHdoZW4gZW50ZXJpbmcgYW5kIGV4aXRpbmdcbiAqICAgaXQuXG4gKiBAcHJvcGVydHkge1N0eWxlUHJvcGVydHlOYW1lQ2FzZSB8IG51bGwgfCB1bmRlZmluZWR9IFtzdHlsZVByb3BlcnR5TmFtZUNhc2U9J2RvbSddXG4gKiAgIFNwZWNpZnkgY2FzaW5nIHRvIHVzZSBmb3IgcHJvcGVydHkgbmFtZXMgaW4gYHN0eWxlYCBvYmplY3RzIChkZWZhdWx0OlxuICogICBgJ2RvbSdgKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFt0YWJsZUNlbGxBbGlnblRvU3R5bGU9dHJ1ZV1cbiAqICAgVHVybiBvYnNvbGV0ZSBgYWxpZ25gIHByb3BzIG9uIGB0ZGAgYW5kIGB0aGAgaW50byBDU1MgYHN0eWxlYCBwcm9wc1xuICogICAoZGVmYXVsdDogYHRydWVgKS5cbiAqXG4gKiBAdHlwZWRlZiBSdW50aW1lRGV2ZWxvcG1lbnRcbiAqICAgUnVudGltZSBmaWVsZHMgd2hlbiBkZXZlbG9wbWVudCBpcyBvbi5cbiAqIEBwcm9wZXJ0eSB7RnJhZ21lbnR9IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50LlxuICogQHByb3BlcnR5IHt0cnVlfSBkZXZlbG9wbWVudFxuICogICBXaGV0aGVyIHRvIHVzZSBganN4REVWYCAod2hlbiBvbikgb3IgYGpzeGAgYW5kIGBqc3hzYCAod2hlbiBvZmYpLlxuICogQHByb3BlcnR5IHtKc3ggfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBEeW5hbWljIEpTWCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3hEZXZ9IGpzeERFVlxuICogICBEZXZlbG9wbWVudCBKU1guXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hzXVxuICogICBTdGF0aWMgSlNYIChvcHRpb25hbCkuXG4gKlxuICogQHR5cGVkZWYgUnVudGltZVByb2R1Y3Rpb25cbiAqICAgUnVudGltZSBmaWVsZHMgd2hlbiBkZXZlbG9wbWVudCBpcyBvZmYuXG4gKiBAcHJvcGVydHkge0ZyYWdtZW50fSBGcmFnbWVudFxuICogICBGcmFnbWVudC5cbiAqIEBwcm9wZXJ0eSB7ZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbZGV2ZWxvcG1lbnRdXG4gKiAgIFdoZXRoZXIgdG8gdXNlIGBqc3hERVZgICh3aGVuIG9uKSBvciBganN4YCBhbmQgYGpzeHNgICh3aGVuIG9mZikgKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7SnN4fSBqc3hcbiAqICAgRHluYW1pYyBKU1guXG4gKiBAcHJvcGVydHkge0pzeERldiB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hERVZdXG4gKiAgIERldmVsb3BtZW50IEpTWCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3h9IGpzeHNcbiAqICAgU3RhdGljIEpTWC5cbiAqXG4gKiBAdHlwZWRlZiBSdW50aW1lVW5rbm93blxuICogICBSdW50aW1lIGZpZWxkcyB3aGVuIGRldmVsb3BtZW50IG1pZ2h0IGJlIG9uIG9yIG9mZi5cbiAqIEBwcm9wZXJ0eSB7RnJhZ21lbnR9IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSBkZXZlbG9wbWVudFxuICogICBXaGV0aGVyIHRvIHVzZSBganN4REVWYCAod2hlbiBvbikgb3IgYGpzeGAgYW5kIGBqc3hzYCAod2hlbiBvZmYpLlxuICogQHByb3BlcnR5IHtKc3ggfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBEeW5hbWljIEpTWCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3hEZXYgfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4REVWXVxuICogICBEZXZlbG9wbWVudCBKU1ggKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7SnN4IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeHNdXG4gKiAgIFN0YXRpYyBKU1ggKG9wdGlvbmFsKS5cbiAqXG4gKiBAdHlwZWRlZiBTb3VyY2VcbiAqICAgSW5mbyBhYm91dCBzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlciB8IHVuZGVmaW5lZH0gY29sdW1uTnVtYmVyXG4gKiAgIENvbHVtbiB3aGVyZSB0aGluZyBzdGFydHMgKDAtaW5kZXhlZCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gZmlsZU5hbWVcbiAqICAgTmFtZSBvZiBzb3VyY2UgZmlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBsaW5lTnVtYmVyXG4gKiAgIExpbmUgd2hlcmUgdGhpbmcgc3RhcnRzICgxLWluZGV4ZWQpLlxuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAnc3ZnJ30gU3BhY2VcbiAqICAgTmFtZXNwYWNlLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBoYXN0IGlzIG5vdCBYTUwuXG4gKiAgID4gSXQgc3VwcG9ydHMgU1ZHIGFzIGVtYmVkZGVkIGluIEhUTUwuXG4gKiAgID4gSXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgZmVhdHVyZXMgYXZhaWxhYmxlIGluIFhNTC5cbiAqICAgPiBQYXNzaW5nIFNWRyBtaWdodCBicmVhayBidXQgZnJhZ21lbnRzIG9mIG1vZGVybiBTVkcgc2hvdWxkIGJlIGZpbmUuXG4gKiAgID4gVXNlIGB4YXN0YCBpZiB5b3UgbmVlZCB0byBzdXBwb3J0IFNWRyBhcyBYTUwuXG4gKlxuICogQHR5cGVkZWYgU3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHByb3BlcnR5IHt1bmtub3dufSBGcmFnbWVudFxuICogICBGcmFnbWVudCBzeW1ib2wuXG4gKiBAcHJvcGVydHkge0FycmF5PFBhcmVudHM+fSBhbmNlc3RvcnNcbiAqICAgU3RhY2sgb2YgcGFyZW50cy5cbiAqIEBwcm9wZXJ0eSB7UGFydGlhbDxDb21wb25lbnRzPn0gY29tcG9uZW50c1xuICogICBDb21wb25lbnRzIHRvIHN3YXAuXG4gKiBAcHJvcGVydHkge0NyZWF0ZX0gY3JlYXRlXG4gKiAgIENyZWF0ZSBzb21ldGhpbmcgaW4gZGV2ZWxvcG1lbnQgb3IgcHJvZHVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7RWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlfSBlbGVtZW50QXR0cmlidXRlTmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVQYXRoXG4gKiAgIEZpbGUgcGF0aC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWdub3JlSW52YWxpZFN0eWxlXG4gKiAgIElnbm9yZSBpbnZhbGlkIENTUyBpbiBgc3R5bGVgIHByb3BzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzS2V5c1xuICogICBHZW5lcmF0ZSBrZXlzIHRvIG9wdGltaXplIGZyYW1ld29ya3MgdGhhdCBzdXBwb3J0IHRoZW0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NOb2RlXG4gKiAgIFBhc3MgYG5vZGVgIHRvIGNvbXBvbmVudHMuXG4gKiBAcHJvcGVydHkge1NjaGVtYX0gc2NoZW1hXG4gKiAgIEN1cnJlbnQgc2NoZW1hLlxuICogQHByb3BlcnR5IHtTdHlsZVByb3BlcnR5TmFtZUNhc2V9IHN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRhYmxlQ2VsbEFsaWduVG9TdHlsZVxuICogICBUdXJuIG9ic29sZXRlIGBhbGlnbmAgcHJvcHMgb24gYHRkYCBhbmQgYHRoYCBpbnRvIENTUyBgc3R5bGVgIHByb3BzLlxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBTdHlsZVxuICogICBTdHlsZSBtYXAuXG4gKlxuICogQHR5cGVkZWYgeydjc3MnIHwgJ2RvbSd9IFN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKlxuICogICBDU1MgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBiYWNrZ3JvdW5kLWNvbG9yYCBhbmQgYC13ZWJraXQtbGluZS1jbGFtcGAuXG4gKiAgIERPTSBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGJhY2tncm91bmRDb2xvcmAgYW5kIGBXZWJraXRMaW5lQ2xhbXBgLlxuICpcbiAqIEB0eXBlZGVmIHtTdHlsZSB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmd9IFZhbHVlXG4gKiAgIFByaW1pdGl2ZSBwcm9wZXJ0eSB2YWx1ZSBhbmQgYFN0eWxlYCBtYXAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UnVudGltZURldmVsb3BtZW50ICYgUmVndWxhckZpZWxkc30gRGV2ZWxvcG1lbnRcbiAqICAgQ29uZmlndXJhdGlvbiAoZGV2ZWxvcG1lbnQpLlxuICogQHR5cGVkZWYge0RldmVsb3BtZW50IHwgUHJvZHVjdGlvbiB8IFVua25vd259IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEB0eXBlZGVmIHtSZWd1bGFyRmllbGRzICYgUnVudGltZVByb2R1Y3Rpb259IFByb2R1Y3Rpb25cbiAqICAgQ29uZmlndXJhdGlvbiAocHJvZHVjdGlvbikuXG4gKiBAdHlwZWRlZiB7UmVndWxhckZpZWxkcyAmIFJ1bnRpbWVVbmtub3dufSBVbmtub3duXG4gKiAgIENvbmZpZ3VyYXRpb24gKHByb2R1Y3Rpb24gb3IgZGV2ZWxvcG1lbnQpLlxuICovXG5cbmltcG9ydCB7c3RyaW5naWZ5IGFzIGNvbW1hc30gZnJvbSAnY29tbWEtc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCB7d2hpdGVzcGFjZX0gZnJvbSAnaGFzdC11dGlsLXdoaXRlc3BhY2UnXG5pbXBvcnQge2ZpbmQsIGhhc3RUb1JlYWN0LCBodG1sLCBzdmd9IGZyb20gJ3Byb3BlcnR5LWluZm9ybWF0aW9uJ1xuaW1wb3J0IHtzdHJpbmdpZnkgYXMgc3BhY2VzfSBmcm9tICdzcGFjZS1zZXBhcmF0ZWQtdG9rZW5zJ1xuaW1wb3J0IHN0eWxlVG9PYmplY3QgZnJvbSAnc3R5bGUtdG8tb2JqZWN0J1xuaW1wb3J0IHtwb2ludFN0YXJ0fSBmcm9tICd1bmlzdC11dGlsLXBvc2l0aW9uJ1xuaW1wb3J0IHtWRmlsZU1lc3NhZ2V9IGZyb20gJ3ZmaWxlLW1lc3NhZ2UnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbmNvbnN0IGVtcHR5TWFwID0gbmV3IE1hcCgpXG5cbmNvbnN0IGNhcCA9IC9bQS1aXS9nXG5jb25zdCBkYXNoU29tZXRoaW5nID0gLy0oW2Etel0pL2dcblxuLy8gYHJlYWN0LWRvbWAgdHJpZ2dlcnMgYSB3YXJuaW5nIGZvciAqYW55KiB3aGl0ZSBzcGFjZSBpbiB0YWJsZXMuXG4vLyBUbyBmb2xsb3cgR0ZNLCBgbWRhc3QtdXRpbC10by1oYXN0YCBpbmplY3RzIGxpbmUgZW5kaW5ncyBiZXR3ZWVuIGVsZW1lbnRzLlxuLy8gT3RoZXIgdG9vbHMgbWlnaHQgZG8gc28gdG9vLCBidXQgdGhleSBkb27igJl0IGRvIGhlcmUsIHNvIHdlIHJlbW92ZSBhbGwgb2Zcbi8vIHRoYXQuXG5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcwODE+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzUxNT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVtYXJranMvcmVtYXJrLXJlYWN0L2lzc3Vlcy82ND4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvMjk+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzMyPi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC80NT4uXG5jb25zdCB0YWJsZUVsZW1lbnRzID0gbmV3IFNldChbJ3RhYmxlJywgJ3Rib2R5JywgJ3RoZWFkJywgJ3Rmb290JywgJ3RyJ10pXG5cbmNvbnN0IHRhYmxlQ2VsbEVsZW1lbnQgPSBuZXcgU2V0KFsndGQnLCAndGgnXSlcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBoYXN0IHRyZWUgdG8gcHJlYWN0LCByZWFjdCwgc29saWQsIHN2ZWx0ZSwgdnVlLCBldGMuLFxuICogd2l0aCBhbiBhdXRvbWF0aWMgSlNYIHJ1bnRpbWUuXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBUcmVlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gKiAgIEpTWCBlbGVtZW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0pzeFJ1bnRpbWUodHJlZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5GcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYEZyYWdtZW50YCBpbiBvcHRpb25zJylcbiAgfVxuXG4gIGNvbnN0IGZpbGVQYXRoID0gb3B0aW9ucy5maWxlUGF0aCB8fCB1bmRlZmluZWRcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGxldCBjcmVhdGVcblxuICBpZiAob3B0aW9ucy5kZXZlbG9wbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3hERVYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBganN4REVWYCBpbiBvcHRpb25zIHdoZW4gYGRldmVsb3BtZW50OiB0cnVlYCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjcmVhdGUgPSBkZXZlbG9wbWVudENyZWF0ZShmaWxlUGF0aCwgb3B0aW9ucy5qc3hERVYpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGpzeGAgaW4gcHJvZHVjdGlvbiBvcHRpb25zJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGpzeHNgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgY3JlYXRlID0gcHJvZHVjdGlvbkNyZWF0ZShmaWxlUGF0aCwgb3B0aW9ucy5qc3gsIG9wdGlvbnMuanN4cylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIEZyYWdtZW50OiBvcHRpb25zLkZyYWdtZW50LFxuICAgIGFuY2VzdG9yczogW10sXG4gICAgY29tcG9uZW50czogb3B0aW9ucy5jb21wb25lbnRzIHx8IHt9LFxuICAgIGNyZWF0ZSxcbiAgICBlbGVtZW50QXR0cmlidXRlTmFtZUNhc2U6IG9wdGlvbnMuZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlIHx8ICdyZWFjdCcsXG4gICAgZmlsZVBhdGgsXG4gICAgaWdub3JlSW52YWxpZFN0eWxlOiBvcHRpb25zLmlnbm9yZUludmFsaWRTdHlsZSB8fCBmYWxzZSxcbiAgICBwYXNzS2V5czogb3B0aW9ucy5wYXNzS2V5cyAhPT0gZmFsc2UsXG4gICAgcGFzc05vZGU6IG9wdGlvbnMucGFzc05vZGUgfHwgZmFsc2UsXG4gICAgc2NoZW1hOiBvcHRpb25zLnNwYWNlID09PSAnc3ZnJyA/IHN2ZyA6IGh0bWwsXG4gICAgc3R5bGVQcm9wZXJ0eU5hbWVDYXNlOiBvcHRpb25zLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSB8fCAnZG9tJyxcbiAgICB0YWJsZUNlbGxBbGlnblRvU3R5bGU6IG9wdGlvbnMudGFibGVDZWxsQWxpZ25Ub1N0eWxlICE9PSBmYWxzZVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gb25lKHN0YXRlLCB0cmVlLCB1bmRlZmluZWQpXG5cbiAgLy8gSlNYIGVsZW1lbnQuXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBUZXh0IG5vZGUgb3Igc29tZXRoaW5nIHRoYXQgdHVybmVkIGludG8gbm90aGluZy5cbiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShcbiAgICB0cmVlLFxuICAgIHN0YXRlLkZyYWdtZW50LFxuICAgIHtjaGlsZHJlbjogcmVzdWx0IHx8IHVuZGVmaW5lZH0sXG4gICAgdW5kZWZpbmVkXG4gIClcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gb25lKHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgY29uc3QgcGFyZW50U2NoZW1hID0gc3RhdGUuc2NoZW1hXG4gICAgbGV0IHNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gICAgaWYgKFxuICAgICAgbm9kZS50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJlxuICAgICAgcGFyZW50U2NoZW1hLnNwYWNlID09PSAnaHRtbCdcbiAgICApIHtcbiAgICAgIHNjaGVtYSA9IHN2Z1xuICAgICAgc3RhdGUuc2NoZW1hID0gc2NoZW1hXG4gICAgfVxuXG4gICAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKVxuICAgIGNvbnN0IHByb3BzID0gY3JlYXRlUHJvcGVydGllcyhzdGF0ZSwgc3RhdGUuYW5jZXN0b3JzKVxuICAgIGxldCB0eXBlID0gc3RhdGUuRnJhZ21lbnRcblxuICAgIHN0YXRlLmFuY2VzdG9ycy5wb3AoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgdGFibGVFbGVtZW50cy5oYXMobm9kZS50YWdOYW1lKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyA/ICF3aGl0ZXNwYWNlKGNoaWxkKSA6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKG93bi5jYWxsKHN0YXRlLmNvbXBvbmVudHMsIG5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHN9ICovIChub2RlLnRhZ05hbWUpXG4gICAgICAgIHR5cGUgPSBzdGF0ZS5jb21wb25lbnRzW2tleV1cblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHN3YXBwZWQgb3V0IGZvciBhIGNvbXBvbmVudDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIHR5cGUgIT09IHN0YXRlLkZyYWdtZW50ICYmXG4gICAgICAgICAgc3RhdGUucGFzc05vZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcHJvcHMubm9kZSA9IG5vZGVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IG5vZGUudGFnTmFtZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkcmVuLmxlbmd0aCA+IDEgPyBjaGlsZHJlbiA6IGNoaWxkcmVuWzBdXG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBwYXJlbnQgc2NoZW1hLlxuICAgIHN0YXRlLnNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gICAgcmV0dXJuIHN0YXRlLmNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBfXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4fSBqc3hcbiAqICAgRHluYW1pYy5cbiAqIEBwYXJhbSB7SnN4fSBqc3hzXG4gKiAgIFN0YXRpYy5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIHByb2R1Y3Rpb24gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcHJvZHVjdGlvbkNyZWF0ZShfLCBqc3gsIGpzeHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKF8sIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBmbiA9IGlzU3RhdGljQ2hpbGRyZW4gPyBqc3hzIDoganN4XG4gICAgcmV0dXJuIGtleSA/IGZuKHR5cGUsIHByb3BzLCBrZXkpIDogZm4odHlwZSwgcHJvcHMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gZmlsZVBhdGhcbiAqICAgUGF0aCB0byBmaWxlLlxuICogQHBhcmFtIHtKc3hEZXZ9IGpzeERFVlxuICogICBEZXZlbG9wbWVudC5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldmVsb3BtZW50Q3JlYXRlKGZpbGVQYXRoLCBqc3hERVYpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBwb2ludCA9IHBvaW50U3RhcnQobm9kZSlcbiAgICByZXR1cm4ganN4REVWKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAga2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHtcbiAgICAgICAgY29sdW1uTnVtYmVyOiBwb2ludCA/IHBvaW50LmNvbHVtbiAtIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlUGF0aCxcbiAgICAgICAgbGluZU51bWJlcjogcG9pbnQgPyBwb2ludC5saW5lIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7UGFyZW50c30gbm9kZVxuICogICBDdXJyZW50IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXk8Q2hpbGQ+fVxuICogICBDaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxDaGlsZD59ICovXG4gIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuICAvLyBOb3RlOiB0ZXN0IHRoaXMgd2hlbiBTb2xpZCBkb2VzbuKAmXQgd2FudCB0byBtZXJnZSBteSB1cGNvbWluZyBQUi5cbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgY29uc3QgY291bnRzQnlUYWdOYW1lID0gc3RhdGUucGFzc0tleXMgPyBuZXcgTWFwKCkgOiBlbXB0eU1hcFxuXG4gIHdoaWxlICgrK2luZGV4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXhdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGtleVxuXG4gICAgaWYgKHN0YXRlLnBhc3NLZXlzICYmIGNoaWxkLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgY29uc3QgY291bnQgPSBjb3VudHNCeVRhZ05hbWUuZ2V0KGNoaWxkLnRhZ05hbWUpIHx8IDBcbiAgICAgIGtleSA9IGNoaWxkLnRhZ05hbWUgKyAnLScgKyBjb3VudFxuICAgICAgY291bnRzQnlUYWdOYW1lLnNldChjaGlsZC50YWdOYW1lLCBjb3VudCArIDEpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gb25lKHN0YXRlLCBjaGlsZCwga2V5KVxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgY2hpbGRyZW4ucHVzaChyZXN1bHQpXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0FycmF5PFBhcmVudHM+fSBhbmNlc3RvcnNcbiAqICAgU3RhY2sgb2YgcGFyZW50cy5cbiAqIEByZXR1cm5zIHtQcm9wc31cbiAqICAgUHJvcHMgZm9yIHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnRpZXMoc3RhdGUsIGFuY2VzdG9ycykge1xuICBjb25zdCBub2RlID0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAxXVxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBjb25zdCBwcm9wcyA9IHt9XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgcHJvcFxuXG4gIGlmICgncHJvcGVydGllcycgaW4gbm9kZSAmJiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYWxpZ25WYWx1ZVxuXG4gICAgZm9yIChwcm9wIGluIG5vZGUucHJvcGVydGllcykge1xuICAgICAgaWYgKHByb3AgIT09ICdjaGlsZHJlbicgJiYgb3duLmNhbGwobm9kZS5wcm9wZXJ0aWVzLCBwcm9wKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVQcm9wZXJ0eShcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBhbmNlc3RvcnMsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBub2RlLnByb3BlcnRpZXNbcHJvcF1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSByZXN1bHRcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0YXRlLnRhYmxlQ2VsbEFsaWduVG9TdHlsZSAmJlxuICAgICAgICAgICAga2V5ID09PSAnYWxpZ24nICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0YWJsZUNlbGxFbGVtZW50Lmhhcyhub2RlLnRhZ05hbWUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhbGlnblZhbHVlID0gdmFsdWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsaWduVmFsdWUpIHtcbiAgICAgIC8vIEFzc3VtZSBzdHlsZSBpcyBhbiBvYmplY3QuXG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChwcm9wcy5zdHlsZSB8fCAocHJvcHMuc3R5bGUgPSB7fSkpXG4gICAgICBzdHlsZVtcbiAgICAgICAgc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJyA/ICd0ZXh0LWFsaWduJyA6ICd0ZXh0QWxpZ24nXG4gICAgICBdID0gYWxpZ25WYWx1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG4vKipcbiAqIEhhbmRsZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7QXJyYXk8UGFyZW50cz59IGFuY2VzdG9yc1xuICogICBTdGFjayBvZiBwYXJlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqICAgS2V5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHZhbHVlXG4gKiAgIGhhc3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJucyB7RmllbGQgfCB1bmRlZmluZWR9XG4gKiAgIEZpZWxkIGZvciBydW50aW1lLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHkoc3RhdGUsIGFuY2VzdG9ycywgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgaW5mbyA9IGZpbmQoc3RhdGUuc2NoZW1hLCBwcm9wKVxuXG4gIC8vIElnbm9yZSBudWxsaXNoIGFuZCBgTmFOYCB2YWx1ZXMuXG4gIGlmIChcbiAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNOYU4odmFsdWUpKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIEFjY2VwdCBgYXJyYXlgLlxuICAgIC8vIE1vc3QgcHJvcHMgYXJlIHNwYWNlLXNlcGFyYXRlZC5cbiAgICB2YWx1ZSA9IGluZm8uY29tbWFTZXBhcmF0ZWQgPyBjb21tYXModmFsdWUpIDogc3BhY2VzKHZhbHVlKVxuICB9XG5cbiAgLy8gUmVhY3Qgb25seSBhY2NlcHRzIGBzdHlsZWAgYXMgb2JqZWN0LlxuICBpZiAoaW5mby5wcm9wZXJ0eSA9PT0gJ3N0eWxlJykge1xuICAgIGxldCBzdHlsZU9iamVjdCA9XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBwYXJzZVN0eWxlKHN0YXRlLCBhbmNlc3RvcnMsIFN0cmluZyh2YWx1ZSkpXG5cbiAgICBpZiAoc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJykge1xuICAgICAgc3R5bGVPYmplY3QgPSB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhzdHlsZU9iamVjdClcbiAgICB9XG5cbiAgICByZXR1cm4gWydzdHlsZScsIHN0eWxlT2JqZWN0XVxuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzdGF0ZS5lbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgPT09ICdyZWFjdCcgJiYgaW5mby5zcGFjZVxuICAgICAgPyBoYXN0VG9SZWFjdFtpbmZvLnByb3BlcnR5XSB8fCBpbmZvLnByb3BlcnR5XG4gICAgICA6IGluZm8uYXR0cmlidXRlLFxuICAgIHZhbHVlXG4gIF1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIENTUyBkZWNsYXJhdGlvbiB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtBcnJheTxOb2Rlcz59IGFuY2VzdG9yc1xuICogICBTdGFjayBvZiBub2Rlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICBDU1MgZGVjbGFyYXRpb25zLlxuICogQHJldHVybnMge1N0eWxlfVxuICogICBQcm9wZXJ0aWVzLlxuICogQHRocm93c1xuICogICBUaHJvd3MgYFZGaWxlTWVzc2FnZWAgd2hlbiBDU1MgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTdHlsZShzdGF0ZSwgYW5jZXN0b3JzLCB2YWx1ZSkge1xuICAvKiogQHR5cGUge1N0eWxlfSAqL1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHRyeSB7XG4gICAgc3R5bGVUb09iamVjdCh2YWx1ZSwgcmVwbGFjZXIpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFzdGF0ZS5pZ25vcmVJbnZhbGlkU3R5bGUpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gLyoqIEB0eXBlIHtFcnJvcn0gKi8gKGVycm9yKVxuICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBWRmlsZU1lc3NhZ2UoJ0Nhbm5vdCBwYXJzZSBgc3R5bGVgIGF0dHJpYnV0ZScsIHtcbiAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgc291cmNlOiAnaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lJyxcbiAgICAgICAgcnVsZUlkOiAnc3R5bGUnXG4gICAgICB9KVxuICAgICAgbWVzc2FnZS5maWxlID0gc3RhdGUuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gICAgICBtZXNzYWdlLnVybCA9XG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lI2Nhbm5vdC1wYXJzZS1zdHlsZS1hdHRyaWJ1dGUnXG5cbiAgICAgIHRocm93IG1lc3NhZ2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG5cbiAgLyoqXG4gICAqIEFkZCBhIENTUyBwcm9wZXJ0eSAobm9ybWFsLCBzbyB3aXRoIGRhc2hlcykgdG8gYHJlc3VsdGAgYXMgYSBET00gQ1NTXG4gICAqIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgIEtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgVmFsdWVcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZXIobmFtZSwgdmFsdWUpIHtcbiAgICBsZXQga2V5ID0gbmFtZVxuXG4gICAgaWYgKGtleS5zbGljZSgwLCAyKSAhPT0gJy0tJykge1xuICAgICAgaWYgKGtleS5zbGljZSgwLCA0KSA9PT0gJy1tcy0nKSBrZXkgPSAnbXMtJyArIGtleS5zbGljZSg0KVxuICAgICAga2V5ID0ga2V5LnJlcGxhY2UoZGFzaFNvbWV0aGluZywgdG9DYW1lbClcbiAgICB9XG5cbiAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBET00gY2FzaW5nIHN0eWxlIG9iamVjdCB0byBhIENTUyBjYXNpbmcgc3R5bGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3R5bGV9IGRvbUNhc2luZ1xuICogQHJldHVybnMge1N0eWxlfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhkb21DYXNpbmcpIHtcbiAgLyoqIEB0eXBlIHtTdHlsZX0gKi9cbiAgY29uc3QgY3NzQ2FzaW5nID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBmcm9tXG5cbiAgZm9yIChmcm9tIGluIGRvbUNhc2luZykge1xuICAgIGlmIChvd24uY2FsbChkb21DYXNpbmcsIGZyb20pKSB7XG4gICAgICBjc3NDYXNpbmdbdHJhbnNmb3JtU3R5bGVUb0Nzc0Nhc2luZyhmcm9tKV0gPSBkb21DYXNpbmdbZnJvbV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3NzQ2FzaW5nXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIGNhc2luZyBzdHlsZSBmaWVsZCB0byBhIENTUyBjYXNpbmcgc3R5bGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSkge1xuICBsZXQgdG8gPSBmcm9tLnJlcGxhY2UoY2FwLCB0b0Rhc2gpXG4gIC8vIEhhbmRsZSBgbXMteHh4YCAtPiBgLW1zLXh4eGAuXG4gIGlmICh0by5zbGljZSgwLCAzKSA9PT0gJ21zLScpIHRvID0gJy0nICsgdG9cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWFrZSBgJDFgIGNhcGl0YWxpemVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBfXG4gKiAgIFdoYXRldmVyLlxuICogQHBhcmFtIHtzdHJpbmd9ICQxXG4gKiAgIFNpbmdsZSBBU0NJSSBhbHBoYWJldGljYWwuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBDYXBpdGFsaXplZCBgJDFgLlxuICovXG5mdW5jdGlvbiB0b0NhbWVsKF8sICQxKSB7XG4gIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpXG59XG5cbi8qKlxuICogTWFrZSBgJDBgIGRhc2ggY2FzZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiAgIENhcGl0YWxpemVkIEFTQ0lJIGxldGVyLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgRGFzaCBhbmQgbG93ZXIgbGV0dGVyLlxuICovXG5mdW5jdGlvbiB0b0Rhc2goJDApIHtcbiAgcmV0dXJuICctJyArICQwLnRvTG93ZXJDYXNlKClcbn1cbiJdLCJuYW1lcyI6WyJzdHJpbmdpZnkiLCJjb21tYXMiLCJ3aGl0ZXNwYWNlIiwiZmluZCIsImhhc3RUb1JlYWN0IiwiaHRtbCIsInN2ZyIsInNwYWNlcyIsInN0eWxlVG9PYmplY3QiLCJwb2ludFN0YXJ0IiwiVkZpbGVNZXNzYWdlIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJlbXB0eU1hcCIsIk1hcCIsImNhcCIsImRhc2hTb21ldGhpbmciLCJ0YWJsZUVsZW1lbnRzIiwiU2V0IiwidGFibGVDZWxsRWxlbWVudCIsInRvSnN4UnVudGltZSIsInRyZWUiLCJvcHRpb25zIiwiRnJhZ21lbnQiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJmaWxlUGF0aCIsImNyZWF0ZSIsImRldmVsb3BtZW50IiwianN4REVWIiwiZGV2ZWxvcG1lbnRDcmVhdGUiLCJqc3giLCJqc3hzIiwicHJvZHVjdGlvbkNyZWF0ZSIsInN0YXRlIiwiYW5jZXN0b3JzIiwiY29tcG9uZW50cyIsImVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSIsImlnbm9yZUludmFsaWRTdHlsZSIsInBhc3NLZXlzIiwicGFzc05vZGUiLCJzY2hlbWEiLCJzcGFjZSIsInN0eWxlUHJvcGVydHlOYW1lQ2FzZSIsInRhYmxlQ2VsbEFsaWduVG9TdHlsZSIsInJlc3VsdCIsIm9uZSIsImNoaWxkcmVuIiwibm9kZSIsImtleSIsInR5cGUiLCJwYXJlbnRTY2hlbWEiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiY3JlYXRlQ2hpbGRyZW4iLCJwcm9wcyIsImNyZWF0ZVByb3BlcnRpZXMiLCJwb3AiLCJoYXMiLCJmaWx0ZXIiLCJjaGlsZCIsImNhbGwiLCJsZW5ndGgiLCJ2YWx1ZSIsIl8iLCJpc1N0YXRpY0NoaWxkcmVuIiwiQXJyYXkiLCJpc0FycmF5IiwiZm4iLCJwb2ludCIsImNvbHVtbk51bWJlciIsImNvbHVtbiIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImxpbmUiLCJpbmRleCIsImNvdW50c0J5VGFnTmFtZSIsImNvdW50IiwiZ2V0Iiwic2V0IiwicHJvcCIsInByb3BlcnRpZXMiLCJhbGlnblZhbHVlIiwiY3JlYXRlUHJvcGVydHkiLCJzdHlsZSIsImluZm8iLCJOdW1iZXIiLCJpc05hTiIsImNvbW1hU2VwYXJhdGVkIiwicHJvcGVydHkiLCJzdHlsZU9iamVjdCIsInBhcnNlU3R5bGUiLCJTdHJpbmciLCJ0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyIsImF0dHJpYnV0ZSIsInJlcGxhY2VyIiwiZXJyb3IiLCJjYXVzZSIsIm1lc3NhZ2UiLCJzb3VyY2UiLCJydWxlSWQiLCJmaWxlIiwidXJsIiwibmFtZSIsInNsaWNlIiwicmVwbGFjZSIsInRvQ2FtZWwiLCJkb21DYXNpbmciLCJjc3NDYXNpbmciLCJmcm9tIiwidHJhbnNmb3JtU3R5bGVUb0Nzc0Nhc2luZyIsInRvIiwidG9EYXNoIiwiJDEiLCJ0b1VwcGVyQ2FzZSIsIiQwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/hast-util-to-jsx-runtime@2.2.0/node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ })

};
;